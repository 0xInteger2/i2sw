<!DOCTYPE html>

<html lang="en">
<head>
<script>
// === Whirl2 helper globals (injected safely) ===
window.provider = window.provider || null;
window.signer = window.signer || null;
window.userAddress = window.userAddress || null;
window.harpoonAbi = window.harpoonAbi || null;
window.factoryAbi = window.factoryAbi || null;
window.gmxAbi = window.gmxAbi || null;
window.uniAbi = window.uniAbi || null;
window.contracts = window.contracts || {};
// Set your deployed addresses here (replace placeholders)
window.factoryAddress = window.factoryAddress || "0xYourFactoryAddress";
window.gmxRouterAddress = window.gmxRouterAddress || "0xYourGMXRouterAddress";
window.uniswapRouterAddress = window.uniswapRouterAddress || "0xYourUniswapRouterAddress";

// helper liveData container
window.liveData = window.liveData || { prices: {}, harpoons: [], currentPlatform: 'gmx' };

// safe logMessage fallback
window.logMessage = window.logMessage || function(msg, level){ console.log(level||'info', msg); };
</script>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>SURF Protocol - Comprehensive Testing Suite</title>
<script>
      // === üîß Set your deployed contract addresses here ===
      // Replace with the actual addresses from your deployment logs
      window.factoryAddress   = "0x0165878A594ca255338adfa4d48449f69242Eb8F"; // HarpoonFactory deployed address
      window.gmxRouterAddress = "0x0000000000000000000000000000000000000002"; // GMX Router deployed address
      window.uniswapRouterAddress = "0x0000000000000000000000000000000000000003";
      </script>
<script>
// Global initializers to avoid ReferenceErrors
window.provider    = null;
window.signer      = null;
window.userAddress = null;
window.harpoonAbi  = null;
window.factoryAbi  = null;
window.contracts   = {};
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/6.7.1/ethers.umd.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet"/>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet"/>

<!-- BEGIN ABI LOADERS -->
<script>
// Ensure global ABIs are loaded using fetch to avoid module issues
function loadAbis() {
    return Promise.all([
        fetch('./artifacts/contracts/Harpoon.sol/HarpoonFactory.json')
            .then(r => r.json())
            .then(j => { window.factoryAbi = j.abi; console.log("‚úÖ Factory ABI loaded", window.factoryAbi.length); }),
        fetch('./artifacts/contracts/Harpoon.sol/IGMXRouter.json')
            .then(r => r.json())
            .then(j => { window.gmxAbi = j.abi; console.log("‚úÖ GMX Router ABI loaded", window.gmxAbi.length); })
    ]);
}
window.loadAbis = loadAbis;
</script>
<!-- END ABI LOADERS -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/6.7.1/ethers.umd.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet"/>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&amp;display=swap" rel="stylesheet"/>
<script>
      // CONSOLIDATED ABI AND CONTRACT INITIALIZATION
      async function initializeEverything() {
        try {
          // Wait for ethers to be available
          if (typeof ethers === 'undefined') {
            console.log("Waiting for ethers...");
            return setTimeout(initializeEverything, 100);
          }
          
          console.log("üîÑ Loading ABIs and initializing contracts...");
          
          // Load all ABIs
          const [harpoon, factory, gmxRouter, uniRouter] = await Promise.all([
            fetch("./artifacts/contracts/Harpoon.sol/Harpoon.json").then(r=>r.json()),
            fetch("./artifacts/contracts/HarpoonFactory.sol/HarpoonFactory.json").then(r=>r.json()),
            fetch("./artifacts/contracts/Harpoon.sol/IGMXRouter.json").then(r=>r.json()),
            fetch("./artifacts/contracts/Harpoon.sol/IUniswapV3Router.json").then(r=>r.json())
          ]);
          
          // Store ABIs globally
          window.harpoonAbi = harpoon.abi;
          window.factoryAbi = factory.abi;
          window.gmxAbi = gmxRouter.abi;
          window.uniAbi = uniRouter.abi;
          
          console.log("‚úÖ Harpoon ABI loaded", window.harpoonAbi.length);
          console.log("‚úÖ Factory ABI loaded", window.factoryAbi.length);
          console.log("‚úÖ GMX Router ABI loaded", window.gmxAbi.length);
          console.log("‚úÖ Uniswap V3 Router ABI loaded", window.uniAbi.length);
          
          // Define getHarpoonInstance function globally
          window.getHarpoonInstance = async function(address) {
            if (!window.harpoonAbi) {
              console.warn("Harpoon ABI not loaded yet");
              return null;
            }
            const provider = window.provider || new ethers.JsonRpcProvider("https://arb1.arbitrum.io/rpc");
            return new ethers.Contract(address, window.harpoonAbi, provider);
          };
          
          // Initialize basic provider for read-only operations
          if (!window.provider) {
            window.provider = window.ethereum
              ? new ethers.BrowserProvider(window.ethereum)
              : new ethers.JsonRpcProvider("https://arb1.arbitrum.io/rpc");
          }
          
          // Initialize factory contract for read-only operations
          const HARPOON_FACTORY_ADDR = "0x0165878A594ca255338adfa4d48449f69242Eb8F";
          if (window.factoryAbi) {
            window.harpoonFactory = new ethers.Contract(HARPOON_FACTORY_ADDR, window.factoryAbi, window.provider);
          }
          
          console.log("‚úÖ Initialization complete");
          
        } catch (error) {
          console.error("‚ùå Initialization failed:", error);
        }
      }
      
      // Start initialization when DOM is ready
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initializeEverything);
      } else {
        initializeEverything();
      }
      </script>
<script>
        async function fetchUserHarpoons(user) {
          if (!window.harpoonFactory) {
            console.warn("Factory not initialized yet");
            return;
          }
          const ids = await window.harpoonFactory.getUserHarpoons(user);
          for (const id of ids) {
            const details = await window.harpoonFactory.getHarpoonDetails(id);
            console.log("Harpoon", id.toString(), details);
          }
        }
        </script>

<style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Inter', sans-serif;
        }

        :root {
            --bg-dark: #0a0a0a;
            --bg-card: #111111;
            --bg-light: #ffffff;
            --border-dark: #2a2a2a;
            --border-light: #e2e8f0;
            --text-primary-dark: #ffffff;
            --text-primary-light: #1a202c;
            --text-secondary: #888888;
            --accent-green: #00ff88;
            --accent-red: #ff3366;
            --accent-blue: #00aaff;
            --accent-purple: #8b5cf6;
            --accent-yellow: #ffaa00;
            --surf-gradient: linear-gradient(135deg, #00d4ff 0%, #0099cc 100%);
            --ocean-gradient: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        /* Theme Variables */
        .theme-dark {
            --bg-primary: var(--bg-dark);
            --bg-secondary: var(--bg-card);
            --border-color: var(--border-dark);
            --text-primary: var(--text-primary-dark);
            --text-secondary: #888888;
        }

        .theme-light {
            --bg-primary: #f8fafc;
            --bg-secondary: var(--bg-light);
            --border-color: var(--border-light);
            --text-primary: var(--text-primary-light);
            --text-secondary: #64748b;
        }

        body {
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
            transition: all 0.3s ease;
        }

        /* Header Styles */
        .header {
            background: var(--ocean-gradient);
            color: white;
            padding: 1.5rem 0;
            position: relative;
            overflow: hidden;
        }

        .header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='none' fill-rule='evenodd'%3E%3Cg fill='%23ffffff' fill-opacity='0.05'%3E%3Cpath d='M36 34v-4h-2v4h-4v2h4v4h2v-4h4v-2h-4zm0-30V0h-2v4h-4v2h4v4h2V6h4V4h-4zM6 34v-4H4v4H0v2h4v4h2v-4h4v-2H6zM6 4V0H4v4H0v2h4v4h2V6h4V4H6z'/%3E%3C/g%3E%3C/g%3E%3C/svg%3E");
        }

        .header-content {
            max-width: 1400px;
            margin: 0 auto;
            padding: 0 2rem;
            position: relative;
            z-index: 10;
        }

        .header-top {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }

        .logo-section {
            display: flex;
            items-center: space-x-3;
        }

        .logo-icon {
            width: 3rem;
            height: 3rem;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 1rem;
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(20px);
        }

        .logo-text h1 {
            font-size: 1.75rem;
            font-weight: 800;
            margin-bottom: 0.25rem;
        }

        .logo-text p {
            color: rgba(255, 255, 255, 0.8);
            font-size: 0.875rem;
        }

        .header-controls {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .theme-toggle {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            cursor: pointer;
            transition: all 0.2s;
            backdrop-filter: blur(20px);
        }

        .theme-toggle:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .mode-selector {
            display: flex;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 0.75rem;
            padding: 0.25rem;
            backdrop-filter: blur(20px);
        }

        .mode-btn {
            padding: 0.5rem 1rem;
            border: none;
            background: transparent;
            color: rgba(255, 255, 255, 0.7);
            border-radius: 0.5rem;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.875rem;
            font-weight: 500;
        }

        .mode-btn.active {
            background: rgba(255, 255, 255, 0.2);
            color: white;
        }

        .connect-wallet {
            background: white;
            color: #667eea;
            padding: 0.75rem 1.5rem;
            border-radius: 0.75rem;
            border: none;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .connect-wallet:hover {
            background: rgba(255, 255, 255, 0.9);
        }

        .connect-wallet:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .network-info {
            display: flex;
            gap: 1.5rem;
            margin-top: 1rem;
            font-size: 0.875rem;
        }

        .network-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            background: rgba(255, 255, 255, 0.1);
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            backdrop-filter: blur(20px);
        }

        .network-label {
            color: rgba(255, 255, 255, 0.7);
        }

        .network-value {
            color: white;
            font-weight: 600;
        }

        /* Container Layout */
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem;
        }

        .main-layout {
            display: grid;
            grid-template-columns: 320px 1fr 400px;
            gap: 2rem;
            min-height: calc(100vh - 200px);
        }

        /* Sidebar Styles */
        .sidebar {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 1rem;
            padding: 1.5rem;
            overflow-y: auto;
        }

        .test-category {
            margin-bottom: 2rem;
        }

        .test-category h3 {
            color: var(--accent-blue);
            font-size: 0.875rem;
            font-weight: 700;
            margin-bottom: 1rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .test-item {
            padding: 0.75rem 1rem;
            margin-bottom: 0.5rem;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 0.5rem;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.875rem;
            font-weight: 500;
        }

        .test-item:hover {
            border-color: var(--accent-blue);
            transform: translateY(-1px);
        }

        .test-item.active {
            background: var(--accent-blue);
            color: white;
            border-color: var(--accent-blue);
        }

        .test-item.passed {
            border-left: 4px solid var(--accent-green);
        }

        .test-item.failed {
            border-left: 4px solid var(--accent-red);
        }

        .test-item.running {
            border-left: 4px solid var(--accent-yellow);
            animation: pulse 1s infinite;
        }

        /* Main Content */
        .main-content {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 1rem;
            overflow: hidden;
        }

        .tab-navigation {
            display: flex;
            background: var(--bg-primary);
            border-bottom: 1px solid var(--border-color);
        }

        .tab-btn {
            padding: 1rem 1.5rem;
            border: none;
            background: transparent;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.2s;
            font-weight: 500;
            border-bottom: 2px solid transparent;
        }

        .tab-btn:hover {
            color: var(--text-primary);
        }

        .tab-btn.active {
            color: var(--accent-blue);
            border-bottom-color: var(--accent-blue);
        }

        .tab-content {
            padding: 2rem;
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* Stats Grid */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1.5rem;
            margin-bottom: 2rem;
        }

        .stat-card {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 1rem;
            padding: 1.5rem;
            transition: all 0.3s ease;
        }

        .stat-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
        }

        .stat-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 1rem;
        }

        .stat-icon {
            width: 3rem;
            height: 3rem;
            border-radius: 1rem;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.25rem;
        }

        .stat-value {
            font-size: 2rem;
            font-weight: 800;
            margin-bottom: 0.25rem;
        }

        .stat-label {
            color: var(--text-secondary);
            font-size: 0.875rem;
            margin-bottom: 0.5rem;
        }

        .stat-change {
            font-size: 0.75rem;
            font-weight: 500;
        }

        /* Results Panel */
        .results-panel {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 1rem;
            padding: 1.5rem;
            overflow-y: auto;
        }

        .results-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 1rem;
        }

        .progress-bar {
            height: 4px;
            background: var(--border-color);
            border-radius: 2px;
            margin-bottom: 1.5rem;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: var(--surf-gradient);
            transition: width 0.3s ease;
        }

        .log-container {
            space-y: 0.5rem;
        }

        .log-entry {
            padding: 0.75rem;
            margin-bottom: 0.5rem;
            background: var(--bg-primary);
            border-left: 3px solid var(--border-color);
            border-radius: 0.5rem;
            font-size: 0.875rem;
            font-family: 'SF Mono', monospace;
        }

        .log-entry.success {
            border-left-color: var(--accent-green);
            background: rgba(0, 255, 136, 0.05);
        }

        .log-entry.error {
            border-left-color: var(--accent-red);
            background: rgba(255, 51, 102, 0.05);
        }

        .log-entry.info {
            border-left-color: var(--accent-blue);
            background: rgba(0, 170, 255, 0.05);
        }

        .log-entry.warning {
            border-left-color: var(--accent-yellow);
            background: rgba(255, 170, 0, 0.05);
        }

        .log-time {
            color: var(--text-secondary);
            margin-right: 0.75rem;
        }

        /* Buttons */
        .btn {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 0.5rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            text-decoration: none;
        }

        .btn-primary {
            background: var(--surf-gradient);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 212, 255, 0.3);
        }

        .btn-success {
            background: var(--accent-green);
            color: white;
        }

        .btn-danger {
            background: var(--accent-red);
            color: white;
        }

        .btn-warning {
            background: var(--accent-yellow);
            color: white;
        }

        .btn-secondary {
            background: var(--text-secondary);
            color: white;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        /* Forms */
        .form-group {
            margin-bottom: 1.5rem;
        }

        .form-label {
            display: block;
            color: var(--text-secondary);
            font-size: 0.875rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .form-input,
        .form-select {
            width: 100%;
            padding: 0.75rem 1rem;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 0.5rem;
            color: var(--text-primary);
            font-family: inherit;
            transition: all 0.2s;
        }

        .form-input:focus,
        .form-select:focus {
            outline: none;
            border-color: var(--accent-blue);
            box-shadow: 0 0 0 3px rgba(0, 170, 255, 0.1);
        }

        /* Data Display */
        .data-display {
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 0.75rem;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
        }

        .data-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem 0;
            border-bottom: 1px solid var(--border-color);
        }

        .data-row:last-child {
            border-bottom: none;
        }

        .data-label {
            color: var(--text-secondary);
            font-weight: 500;
        }

        .data-value {
            color: var(--text-primary);
            font-weight: 700;
        }

        .data-value.positive {
            color: var(--accent-green);
        }

        .data-value.negative {
            color: var(--accent-red);
        }

        .data-value.address {
            font-family: 'SF Mono', monospace;
            font-size: 0.75rem;
            color: var(--accent-blue);
        }

        /* Animations */
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .spinner {
            display: inline-block;
            width: 1rem;
            height: 1rem;
            border: 2px solid var(--border-color);
            border-top: 2px solid var(--accent-blue);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        /* Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            padding: 1rem;
        }

        .modal-content {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 1rem;
            padding: 2rem;
            max-width: 600px;
            width: 100%;
            max-height: 90vh;
            overflow-y: auto;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
        }

        .modal-title {
            font-size: 1.5rem;
            font-weight: 700;
        }

        .modal-close {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0.5rem;
        }

        /* Responsive */
        @media (max-width: 1200px) {
            .main-layout {
                grid-template-columns: 280px 1fr 350px;
            }
        }

        @media (max-width: 968px) {
            .main-layout {
                grid-template-columns: 1fr;
                gap: 1rem;
            }
            
            .sidebar {
                order: 2;
            }
            
            .results-panel {
                order: 3;
            }
        }

        @media (max-width: 640px) {
            .container {
                padding: 1rem;
            }
            
            .header-top {
                flex-direction: column;
                gap: 1rem;
            }
            
            .stats-grid {
                grid-template-columns: 1fr;
            }
        }

        /* Chart Container */
        .chart-container {
            position: relative;
            height: 300px;
            margin-bottom: 2rem;
        }

        /* Price Ticker */
        .price-ticker {
            display: flex;
            gap: 1.5rem;
            padding: 1rem;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 0.75rem;
            margin-bottom: 2rem;
            overflow-x: auto;
        }

        .price-item {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            white-space: nowrap;
        }

        .price-label {
            color: var(--text-secondary);
            font-size: 0.875rem;
            font-weight: 500;
        }

        .price-value {
            color: var(--accent-green);
            font-weight: 700;
            font-size: 1.125rem;
        }

        /* Platform Forms */
        .platform-form {
            transition: all 0.3s ease;
        }

        .platform-form.active {
            display: block;
        }

        /* Flip Card Animation */
        .flip-card-container {
            position: relative;
            width: 100%;
            transition: transform 0.6s;
            transform-style: preserve-3d;
        }

        .flip-card-face {
            width: 100%;
            transition: transform 0.6s ease-in-out;
            backface-visibility: hidden;
        }

        .flip-card-face.active {
            display: block;
        }

        /* Section Headers */
        .section-header {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-bottom: 1.5rem;
        }

        .section-icon {
            width: 3rem;
            height: 3rem;
            border-radius: 1rem;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.25rem;
        }

        .section-title {
            font-size: 1.5rem;
            font-weight: 700;
        }

        .section-subtitle {
            color: var(--text-secondary);
            font-size: 0.875rem;
        }
    </style>
</head>
<body class="theme-dark">
<div class="header">
<div class="header-content">
<div class="header-top">
<div class="logo-section">
<div class="logo-icon">
<i class="fas fa-anchor"></i>
</div>
<div class="logo-text">
<h1>SURF PROTOCOL</h1>
<p>Comprehensive Testing Suite</p>
</div>
</div>
<div class="header-controls">
<button class="theme-toggle" onclick="toggleTheme()">
<i class="fas fa-sun" id="themeIcon"></i>
</button>
<div class="mode-selector">
<button class="mode-btn active" onclick="switchMode('testing')">
<i class="fas fa-code"></i> Testing
                        </button>
<button class="mode-btn" onclick="switchMode('user')">
<i class="fas fa-user"></i> User
                        </button>
</div>
<button class="connect-wallet" id="connectWallet">
<i class="fas fa-wallet"></i>
<span>Connect Wallet</span>
</button>
</div>
</div>
<div class="network-info">
<div class="network-item">
<span class="network-label">Network:</span>
<span class="network-value" id="networkName">NOT CONNECTED</span>
</div>
<div class="network-item">
<span class="network-label">Block:</span>
<span class="network-value" id="blockNumber">0</span>
</div>
<div class="network-item">
<span class="network-label">Wallet:</span>
<span class="network-value" id="walletAddress">NOT CONNECTED</span>
</div>
<div class="network-item">
<span class="network-label">ETH:</span>
<span class="network-value" id="ethBalance">0.0000</span>
</div>
</div>
</div>
</div>

<div class="container">
<div class="main-layout">
<!-- Test Sidebar -->
<div class="sidebar">
<div class="test-category">
<h3>Quick Actions</h3>
<button class="btn btn-primary" onclick="runAllTests()" style="width: 100%; margin-bottom: 1rem;">
<i class="fas fa-play"></i> Run All Tests
</button>
<button class="btn btn-warning" onclick="resetEnvironment()" style="width: 100%; margin-bottom: 1rem;">
<i class="fas fa-refresh"></i> Reset Environment
</button>
<button class="btn btn-success" onclick="mintTestTokens()" style="width: 100%; margin-bottom: 1rem;">
<i class="fas fa-coins"></i> Mint Test Tokens
</button>
</div>

<div class="test-category">
<h3>Contract Verification</h3>
<div class="test-item" onclick="runTest('verifyDeployments')">Verify All Deployments</div>
<div class="test-item" onclick="runTest('checkBytecode')">Check Bytecode</div>
<div class="test-item" onclick="runTest('verifyOwnership')">Verify Ownership</div>
</div>

<div class="test-category">
<h3>Token &amp; NFT Tests</h3>
<div class="test-item" onclick="runTest('mintMockTokens')">Mint Mock Tokens</div>
<div class="test-item" onclick="runTest('testERC20Functions')">Test ERC20 Functions</div>
<div class="test-item" onclick="runTest('testERC721Functions')">Test ERC721 Functions</div>
<div class="test-item" onclick="runTest('testNFTAccess')">Test NFT Access Control</div>
</div>

<div class="test-category">
<h3>LP Vault Tests</h3>
<div class="test-item" onclick="runTest('testDeposit')">Test Deposit</div>
<div class="test-item" onclick="runTest('testWithdraw')">Test Withdraw</div>
<div class="test-item" onclick="runTest('testRewardDistribution')">Test Reward Distribution</div>
<div class="test-item" onclick="runTest('testClaimRewards')">Test Claim Rewards</div>
<div class="test-item" onclick="runTest('testEmergencyWithdraw')">Test Emergency Withdraw</div>
</div>

<div class="test-category">
<h3>Harpoon Tests</h3>
<div class="test-item" onclick="runTest('testCreateHarpoon')">Test Create Harpoon</div>
<div class="test-item" onclick="runTest('testOpenPosition')">Test Open Position</div>
<div class="test-item" onclick="runTest('testClosePosition')">Test Close Position</div>
<div class="test-item" onclick="runTest('testVotingMechanism')">Test Voting Mechanism</div>
<div class="test-item" onclick="runTest('testPnLCalculation')">Test P&amp;L Calculation</div>
</div>

<div class="test-category">
<h3>Integration Tests</h3>
<div class="test-item" onclick="runTest('testFullFlow')">Test Full Protocol Flow</div>
<div class="test-item" onclick="runTest('testMultiUser')">Test Multi-User Scenario</div>
<div class="test-item" onclick="runTest('testGasOptimization')">Test Gas Optimization</div>
<div class="test-item" onclick="runTest('testEdgeCases')">Test Edge Cases</div>
</div>
</div>

<!-- Main Content -->
<div class="main-content">
<div class="tab-navigation">
<button class="tab-btn active" onclick="switchTab('dashboard')">
<i class="fas fa-chart-line"></i> Dashboard
</button>
<button class="tab-btn" onclick="switchTab('vault')">
<i class="fas fa-coins"></i> LP Vault
</button>
<button class="tab-btn" onclick="switchTab('harpoons')">
<i class="fas fa-anchor"></i> Harpoons
</button>
<button class="tab-btn" onclick="switchTab('contracts')">
<i class="fas fa-file-contract"></i> Contracts
</button>
<button class="tab-btn" onclick="switchTab('analytics')">
<i class="fas fa-chart-bar"></i> Analytics
</button>
</div>

<!-- Dashboard Tab -->
<div class="tab-content active" id="dashboard">
<!-- Price Ticker -->
<div class="price-ticker">
<div class="price-item">
<span class="price-label">BTC/USD:</span>
<span class="price-value" id="btcPrice">$67,500</span>
</div>
<div class="price-item">
<span class="price-label">ETH/USD:</span>
<span class="price-value" id="ethPrice">$3,420</span>
</div>
<div class="price-item">
<span class="price-label">SURF/ETH LP:</span>
<span class="price-value" id="lpPrice">$125.50</span>
</div>
<div class="price-item">
<span class="price-label">GAS:</span>
<span class="price-value" id="gasPrice">25 GWEI</span>
</div>
</div>
<!-- Stats Grid -->
<div class="stats-grid">
<div class="stat-card">
<div class="stat-header">
<div>
<div class="stat-label">Portfolio Value</div>
<div class="stat-value" id="portfolioValue">$0.00</div>
<div class="stat-change positive">+2.34% (24h)</div>
</div>
<div class="stat-icon" style="background: var(--surf-gradient);">
<i class="fas fa-chart-line" style="color: white;"></i>
</div>
</div>
</div>
<div class="stat-card">
<div class="stat-header">
<div>
<div class="stat-label">Total P&amp;L</div>
<div class="stat-value positive" id="totalPnL">$0.00</div>
<div class="stat-change positive">+15.67%</div>
</div>
<div class="stat-icon" style="background: var(--accent-green);">
<i class="fas fa-trophy" style="color: white;"></i>
</div>
</div>
</div>
<div class="stat-card">
<div class="stat-header">
<div>
<div class="stat-label">Active Harpoons</div>
<div class="stat-value" id="activeHarpoons">0</div>
<div class="stat-change">2 total</div>
</div>
<div class="stat-icon" style="background: var(--accent-red);">
<i class="fas fa-anchor" style="color: white;"></i>
</div>
</div>
</div>
<div class="stat-card">
<div class="stat-header">
<div>
<div class="stat-label">LP Shares</div>
<div class="stat-value" id="lpShares">0.0000</div>
<div class="stat-change">Earning rewards</div>
</div>
<div class="stat-icon" style="background: var(--accent-purple);">
<i class="fas fa-coins" style="color: white;"></i>
</div>
</div>
</div>
</div>
<!-- Contract Status -->
<div class="section-header">
<div class="section-icon" style="background: var(--accent-blue); color: white;">
<i class="fas fa-server"></i>
</div>
<div>
<div class="section-title">Contract Status</div>
<div class="section-subtitle">Deployment verification and health checks</div>
</div>
</div>
<div class="data-display">
<div class="data-row">
<span class="data-label">LP Vault</span>
<span class="data-value" id="vaultStatus">NOT DEPLOYED</span>
</div>
<div class="data-row">
<span class="data-label">Harpoon Factory</span>
<span class="data-value" id="factoryStatus">NOT DEPLOYED</span>
</div>
<div class="data-row">
<span class="data-label">CCIP Bridge</span>
<span class="data-value" id="bridgeStatus">NOT DEPLOYED</span>
</div>
<div class="data-row">
<span class="data-label">Mock USDC</span>
<span class="data-value" id="usdcStatus">NOT DEPLOYED</span>
</div>
<div class="data-row">
<span class="data-label">Mock LP Token</span>
<span class="data-value" id="lpTokenStatus">NOT DEPLOYED</span>
</div>
</div>
</div>

<!-- LP Vault Tab -->
<div class="tab-content" id="vault">
<div class="section-header">
<div class="section-icon" style="background: var(--surf-gradient); color: white;">
<i class="fas fa-coins"></i>
</div>
<div>
<div class="section-title">LP Vault Operations</div>
<div class="section-subtitle">Stake SURF/ETH LP tokens to earn rewards</div>
</div>
</div>
<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 2rem;">
<!-- Stake Operations -->
<div>
<h3 style="margin-bottom: 1rem; color: var(--accent-green);">Stake LP Tokens</h3>
<div class="form-group">
<label class="form-label">LP Amount to Stake</label>
<input class="form-input" id="stakeAmount" placeholder="10.0" step="0.1" type="number"/>
</div>
<div style="display: flex; gap: 1rem; margin-bottom: 2rem;">
<button class="btn btn-primary" onclick="approveLP()">
<i class="fas fa-check"></i> Approve LP
</button>
<button class="btn btn-success" onclick="stakeLP()">
<i class="fas fa-plus"></i> Stake LP
</button>
</div>
<h3 style="margin-bottom: 1rem; color: var(--accent-red);">Unstake Operations</h3>
<div class="form-group">
<label class="form-label">Shares to Unstake</label>
<input class="form-input" id="unstakeAmount" placeholder="10.0" step="0.1" type="number"/>
</div>
<div style="display: flex; gap: 1rem;">
<button class="btn btn-warning" onclick="unstakeLP()">
<i class="fas fa-minus"></i> Unstake
</button>
<button class="btn btn-danger" onclick="emergencyWithdraw()">
<i class="fas fa-exclamation-triangle"></i> Emergency
</button>
</div>
</div>
<!-- Position Info -->
<div>
<h3 style="margin-bottom: 1rem;">Your Position</h3>
<div class="data-display">
<div class="data-row">
<span class="data-label">LP Shares</span>
<span class="data-value" id="userShares">0.0000</span>
</div>
<div class="data-row">
<span class="data-label">LP Value</span>
<span class="data-value" id="userLPValue">$0.00</span>
</div>
<div class="data-row">
<span class="data-label">Pending Rewards</span>
<span class="data-value positive" id="pendingRewards">$0.00</span>
</div>
<div class="data-row">
<span class="data-label">LP Token Balance</span>
<span class="data-value" id="lpTokenBalance">0.0000</span>
</div>
</div>
<button class="btn btn-success" onclick="claimRewards()" style="width: 100%; margin-top: 1rem;">
<i class="fas fa-gift"></i> Claim Rewards
</button>
</div>
</div>
<!-- Reward Distribution (Admin) -->
<div style="margin-top: 3rem;">
<h3 style="margin-bottom: 1rem; color: var(--accent-purple);">Reward Distribution (Admin)</h3>
<div style="display: grid; grid-template-columns: 1fr auto auto; gap: 1rem; align-items: end;">
<div class="form-group" style="margin-bottom: 0;">
<label class="form-label">Reward Amount (USDC)</label>
<input class="form-input" id="rewardAmount" placeholder="100" step="10" type="number"/>
</div>
<button class="btn btn-primary" onclick="approveReward()">
<i class="fas fa-check"></i> Approve
</button>
<button class="btn btn-success" onclick="distributeReward()">
<i class="fas fa-gift"></i> Distribute
</button>
</div>
</div>
</div>

<!-- Harpoons Tab -->
<div class="tab-content" id="harpoons">
<div class="section-header">
<div class="section-icon" style="background: var(--accent-red); color: white;">
<i class="fas fa-anchor"></i>
</div>
<div>
<div class="section-title">Harpoon Trading</div>
<div class="section-subtitle">Create and manage leveraged trading positions</div>
</div>
<button class="btn btn-primary" onclick="showCreateHarpoonModal()">
<i class="fas fa-plus"></i> Create Harpoon
</button>
</div>
<div id="harpoonsList">
<div style="text-align: center; padding: 4rem 2rem;">
<div style="width: 4rem; height: 4rem; background: var(--border-color); border-radius: 50%; display: flex; align-items: center; justify-content: center; margin: 0 auto 2rem;">
<i class="fas fa-anchor" style="color: var(--text-secondary); font-size: 1.5rem;"></i>
</div>
<h3 style="margin-bottom: 1rem;">No Harpoons Yet</h3>
<p style="color: var(--text-secondary); margin-bottom: 2rem;">Create your first harpoon to start trading with leverage</p>
<button class="btn btn-primary" onclick="showCreateHarpoonModal()">
<i class="fas fa-anchor"></i> Create Your First Harpoon
</button>
</div>
</div>
</div>

<!-- Contracts Tab -->
<div class="tab-content" id="contracts">
<div class="section-header">
<div class="section-icon" style="background: var(--accent-yellow); color: white;">
<i class="fas fa-file-contract"></i>
</div>
<div>
<div class="section-title">Contract Information</div>
<div class="section-subtitle">Addresses, verification, and admin controls</div>
</div>
</div>
<!-- Contract Addresses -->
<h3 style="margin-bottom: 1rem;">Contract Addresses</h3>
<div class="data-display">
<div class="data-row">
<span class="data-label">Mock USDC</span>
<span class="data-value address">0x5FbDB2315678afecb367f032d93F642f64180aa3</span>
</div>
<div class="data-row">
<span class="data-label">Mock LP Token</span>
<span class="data-value address">0xe7f1725E7734CE288F8367e1Bb143E90bb3F0512</span>
</div>
<div class="data-row">
<span class="data-label">SURF NFT</span>
<span class="data-value address">0x9fE46736679d2D9a65F0992F2272dE9f3c7fa6e0</span>
</div>
<div class="data-row">
<span class="data-label">Mumu NFT</span>
<span class="data-value address">0xCf7Ed3AccA5a467e9e704C703E8D87F634fB0Fc9</span>
</div>
<div class="data-row">
<span class="data-label">LP Vault</span>
<span class="data-value address">0xDc64a140Aa3E981100a9becA4E685f962f0cF6C9</span>
</div>
<div class="data-row">
<span class="data-label">Harpoon Factory</span>
<span class="data-value address">0x0165878A594ca255338adfa4d48449f69242Eb8F</span>
</div>
</div>
<!-- Contract Verification -->
<h3 style="margin-bottom: 1rem; margin-top: 2rem;">Contract Verification</h3>
<div style="display: flex; gap: 1rem; margin-bottom: 2rem;">
<button class="btn btn-primary" onclick="verifyAllContracts()">
<i class="fas fa-check-double"></i> Verify All
</button>
<button class="btn btn-secondary" onclick="checkContractSizes()">
<i class="fas fa-ruler"></i> Check Sizes
</button>
<button class="btn btn-secondary" onclick="checkContractOwners()">
<i class="fas fa-crown"></i> Check Owners
</button>
</div>
</div>

<!-- Analytics Tab -->
<div class="tab-content" id="analytics">
<div class="section-header">
<div class="section-icon" style="background: var(--accent-purple); color: white;">
<i class="fas fa-chart-bar"></i>
</div>
<div>
<div class="section-title">Live Protocol Analytics</div>
<div class="section-subtitle">Real-time performance metrics from your harpoons</div>
</div>
</div>
<div class="chart-container">
<canvas id="portfolioChart"></canvas>
</div>
<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; margin-bottom: 2rem;">
<div class="stat-card">
<div class="stat-label">Total Positions</div>
<div class="stat-value" id="analyticsTotal" style="color: var(--accent-blue);">0</div>
<div class="stat-change" id="analyticsActivePositions">0 active</div>
</div>
<div class="stat-card">
<div class="stat-label">Win Rate</div>
<div class="stat-value" id="analyticsWinRate" style="color: var(--accent-green);">0%</div>
<div class="stat-change" id="analyticsWinLoss">0W / 0L</div>
</div>
<div class="stat-card">
<div class="stat-label">Total P&amp;L</div>
<div class="stat-value" id="analyticsTotalPnL" style="color: var(--accent-green);">$0.00</div>
<div class="stat-change" id="analyticsPnLPercent">0.00%</div>
</div>
<div class="stat-card">
<div class="stat-label">Best Trade</div>
<div class="stat-value" id="analyticsBestTrade" style="color: var(--accent-green);">$0.00</div>
<div class="stat-change" id="analyticsBestTradePercent">0.00%</div>
</div>
</div>
<div class="section-header">
<div class="section-icon" style="background: var(--accent-red); color: white;">
<i class="fas fa-anchor"></i>
</div>
<div>
<div class="section-title">Live Harpoon Performance</div>
<div class="section-subtitle">Real-time tracking of all positions</div>
</div>
</div>
<div id="analyticsHarpoonsList">
<div style="text-align: center; padding: 2rem;">
<p style="color: var(--text-secondary);">No harpoons created yet. Create your first harpoon to see analytics.</p>
</div>
</div>
</div>
</div>

<!-- Results Panel -->
<div class="results-panel">
<div class="results-header">
<h3 style="color: var(--accent-green);">System Logs</h3>
<button class="btn btn-secondary" onclick="clearLogs()" style="padding: 0.5rem;">
<i class="fas fa-trash"></i>
</button>
</div>
<div class="log-container" id="testOutput">
<div class="log-entry info">
<span class="log-time">[00:00:00]</span>
System initialized. Connect wallet to begin.
</div>
</div>
</div>
</div>
</div>

<!-- Create Harpoon Modal -->
<div class="modal-overlay" id="createHarpoonModal" style="display: none;">
<div class="modal-content">
<div class="modal-header">
<h2 class="modal-title">Create Harpoon Position</h2>
<button class="modal-close" onclick="hideCreateHarpoonModal()">
<i class="fas fa-times"></i>
</button>
</div>
<!-- Platform Selector -->
<div style="display: flex; justify-content: center; margin-bottom: 2rem;">
<div class="mode-selector">
<button class="mode-btn active" id="gmxTab" onclick="switchPlatform('gmx')">
<i class="fas fa-chart-line"></i> GMX
</button>
<button class="mode-btn" id="uniswapTab" onclick="switchPlatform('uniswap')">
<i class="fas fa-exchange-alt"></i> Uniswap V3
</button>
</div>
</div>
<!-- GMX Form -->
<div class="platform-form active" id="gmxForm">
<div style="background: linear-gradient(135deg, #ff6b6b 0%, #ff8e8e 100%); padding: 1rem; border-radius: 0.75rem; margin-bottom: 1.5rem;">
<h3 style="color: white; margin-bottom: 0.5rem; display: flex; align-items: center; gap: 0.5rem;">
<i class="fas fa-chart-line"></i> GMX Perpetuals
</h3>
<p style="color: rgba(255,255,255,0.9); font-size: 0.875rem;">Trade with up to 30x leverage on decentralized perpetual exchange</p>
</div>
<form id="gmxHarpoonForm" onsubmit="createGMXHarpoon(event)">
<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
<div class="form-group">
<label class="form-label">Target Asset</label>
<select class="form-select" id="gmxTargetAsset" onchange="updateGMXSummary()">
<option value="btc">BTC (Bitcoin)</option>
<option value="eth">ETH (Ethereum)</option>
<option value="sol">SOL (Solana)</option>
<option value="avax">AVAX (Avalanche)</option>
</select>
</div>
<div class="form-group">
<label class="form-label">Collateral (USDC)</label>
<input class="form-input" id="gmxCollateralAmount" min="100" oninput="updateGMXSummary()" placeholder="1000" type="number"/>
</div>
<div class="form-group">
<label class="form-label">Leverage (Max 30x)</label>
<select class="form-select" id="gmxLeverage" onchange="updateGMXSummary()">
<option value="2">2x</option>
<option selected value="5">5x</option>
<option value="10">10x</option>
<option value="15">15x</option>
<option value="20">20x</option>
<option value="30">30x</option>
</select>
</div>
<div class="form-group">
<label class="form-label">Position Type</label>
<select class="form-select" id="gmxPositionType" onchange="updateGMXSummary()">
<option value="true">LONG (Bullish)</option>
<option value="false">SHORT (Bearish)</option>
</select>
</div>
<div class="form-group">
<label class="form-label">Take Profit (%)</label>
<input class="form-input" id="gmxTakeProfit" max="500" min="5" placeholder="50" type="number"/>
</div>
<div class="form-group">
<label class="form-label">Stop Loss (%)</label>
<input class="form-input" id="gmxStopLoss" max="90" min="5" placeholder="20" type="number"/>
</div>
</div>
<div class="data-display" style="margin: 1.5rem 0;">
<h3 style="margin-bottom: 1rem; color: var(--accent-red);">GMX Position Analytics</h3>
<div class="data-row">
<span class="data-label">Current Price:</span>
<span class="data-value" id="gmxCurrentPrice">$0</span>
</div>
<div class="data-row">
<span class="data-label">Position Size:</span>
<span class="data-value" id="gmxPositionSize">$0</span>
</div>
<div class="data-row">
<span class="data-label">Liquidation Price:</span>
<span class="data-value" id="gmxLiquidationPrice">$0</span>
</div>
<div class="data-row">
<span class="data-label">Platform Fee:</span>
<span class="data-value">0.1% + 0.001 ETH</span>
</div>
</div>
<button class="btn btn-primary" style="width: 100%;" type="submit">
<i class="fas fa-chart-line"></i> Create GMX Position
</button>
</form>
</div>
<!-- Uniswap Form -->
<div class="platform-form" id="uniswapForm" style="display: none;">
<div style="background: linear-gradient(135deg, #ff007a 0%, #ff4da6 100%); padding: 1rem; border-radius: 0.75rem; margin-bottom: 1.5rem;">
<h3 style="color: white; margin-bottom: 0.5rem; display: flex; align-items: center; gap: 0.5rem;">
<i class="fas fa-exchange-alt"></i> Uniswap V3
</h3>
<p style="color: rgba(255,255,255,0.9); font-size: 0.875rem;">Create concentrated liquidity positions with custom ranges</p>
</div>
<form id="uniswapHarpoonForm" onsubmit="createUniswapHarpoon(event)">
<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
<div class="form-group">
<label class="form-label">Token Pair</label>
<select class="form-select" id="uniswapPair" onchange="updateUniswapSummary()">
<option value="eth-usdc">ETH/USDC</option>
<option value="btc-usdc">WBTC/USDC</option>
<option value="eth-btc">ETH/WBTC</option>
<option value="dai-usdc">DAI/USDC</option>
</select>
</div>
<div class="form-group">
<label class="form-label">Total Value (USD)</label>
<input class="form-input" id="uniswapTotalValue" min="100" oninput="updateUniswapSummary()" placeholder="1000" type="number"/>
</div>
<div class="form-group">
<label class="form-label">Fee Tier</label>
<select class="form-select" id="uniswapFeeTier" onchange="updateUniswapSummary()">
<option value="0.05">0.05% (Stablecoins)</option>
<option selected value="0.3">0.30% (Standard)</option>
<option value="1">1.00% (Exotic)</option>
</select>
</div>
<div class="form-group">
<label class="form-label">Strategy</label>
<select class="form-select" id="uniswapStrategy" onchange="updateUniswapSummary()">
<option value="narrow">Narrow Range (Higher APY)</option>
<option selected value="wide">Wide Range (Safer)</option>
<option value="full">Full Range (Passive)</option>
</select>
</div>
<div class="form-group">
<label class="form-label">Min Price Range (%)</label>
<input class="form-input" id="uniswapMinRange" max="0" oninput="updateUniswapSummary()" placeholder="-10" type="number"/>
</div>
<div class="form-group">
<label class="form-label">Max Price Range (%)</label>
<input class="form-input" id="uniswapMaxRange" min="0" oninput="updateUniswapSummary()" placeholder="10" type="number"/>
</div>
</div>
<div class="data-display" style="margin: 1.5rem 0;">
<h3 style="margin-bottom: 1rem; color: var(--accent-purple);">Uniswap Position Analytics</h3>
<div class="data-row">
<span class="data-label">Estimated APY:</span>
<span class="data-value" id="uniswapAPY">15-25%</span>
</div>
<div class="data-row">
<span class="data-label">Current Price:</span>
<span class="data-value" id="uniswapCurrentPrice">$0</span>
</div>
<div class="data-row">
<span class="data-label">Impermanent Loss Risk:</span>
<span class="data-value" id="uniswapILRisk">Medium</span>
</div>
<div class="data-row">
<span class="data-label">Token Allocation:</span>
<span class="data-value" id="uniswapAllocation">50/50</span>
</div>
</div>
<button class="btn btn-primary" style="width: 100%;" type="submit">
<i class="fas fa-exchange-alt"></i> Create Uniswap Position
</button>
</form>
</div>
</div>
</div>

<script>
        // ============================================
        // CONTRACT CONFIGURATION
        // ============================================
        
        const CONTRACTS = {
            MOCK_USDC: "0x5FbDB2315678afecb367f032d93F642f64180aa3",
            MOCK_LP_TOKEN: "0xe7f1725E7734CE288F8367e1Bb143E90bb3F0512",
            MOCK_SURF_NFT: "0x9fE46736679d2D9a65F0992F2272dE9f3c7fa6e0",
            MOCK_MUMU_NFT: "0xCf7Ed3AccA5a467e9e704C703E8D87F634fB0Fc9",
            LP_VAULT: "0xDc64a140Aa3E981100a9becA4E685f962f0cF6C9",
            CCIP_BRIDGE: "0x5FC8d32690cc91D4c39d9d3abcBD16989F875707",
            HARPOON_FACTORY: "0x0165878A594ca255338adfa4d48449f69242Eb8F",
            PROTOCOL_MANAGER: "0xa513E6E4b8f2a923D98304ec87F64353C4D5C853"
        };

        const ABIS = {
            ERC20: [
                "function balanceOf(address owner) view returns (uint256)",
                "function approve(address spender, uint256 amount) returns (bool)",
                "function allowance(address owner, address spender) view returns (uint256)",
                "function transfer(address to, uint256 amount) returns (bool)",
                "function decimals() view returns (uint8)",
                "function mint(address to, uint256 amount)"
            ],
            ERC721: [
                "function balanceOf(address owner) view returns (uint256)",
                "function mint(address to, uint256 tokenId)",
                "function setApprovalForAll(address operator, bool approved)"
            ],
            LPVault: [
                "function deposit(uint256 lpAmount)",
                "function withdraw(uint256 shareAmount)",
                "function claimRewards()",
                "function emergencyWithdraw()",
                "function notifyRewardAmount(uint256 usdcAmount)",
                "function getUserInfo(address user) view returns (uint256 shares, uint256 rewardDebt, uint256 pendingUSDC)",
                "function pendingRewards(address user) view returns (uint256)",
                "function lpBalance() view returns (uint256)",
                "function totalShares() view returns (uint256)",
                "function paused() view returns (bool)",
                "function owner() view returns (address)"
            ],
            HarpoonFactory: [
                "function createHarpoon((address,uint256,uint256,bool,uint256,string,uint256,bytes)) payable returns (address)",
                "function hasEligibleNFT(address user) view returns (bool)",
                "function getUserHarpoons(address user) view returns (uint256[])",
                "function getHarpoon(uint256 id) view returns (address)",
                "function harpoonCount() view returns (uint256)",
                "function creationFee() view returns (uint256)",
                "function paused() view returns (bool)",
                "function owner() view returns (address)"
            ]
        };

        // ============================================
        // GLOBAL STATE - FIXED CONTRACT INITIALIZATION
        // ============================================
        
        window.provider, window.signer, window.userAddress;
        window.contracts = {};
        let testResults = new Map();
        let currentMode = 'testing';
        let currentTheme = 'dark';
        let blockUpdateInterval;
        let priceUpdateInterval;
        let portfolioChart;
        
        // Live price data
        let liveData = {
            prices: { btc: 110000, eth: 4300, lp: 125.50, gas: 25 },
            portfolio: {
                value: 0,
                pnl: 0,
                lpShares: 0,
                pendingRewards: 0
            },
            harpoons: []
        };
        
        // Price cache to avoid excessive API calls (but actually fetch live data)
        let priceCache = {
            eth: { price: 0, timestamp: 0 },
            btc: { price: 0, timestamp: 0 },
            lp: { price: 0, timestamp: 0 }
        };

        // ============================================
        // FIXED INITIALIZATION FUNCTION
        // ============================================
        
        function initializeContractsFixed() {
            // FIXED: Create both naming patterns to solve the "factory not initialized" issue
            window.contracts.mockUSDC = new ethers.Contract(CONTRACTS.MOCK_USDC, ABIS.ERC20, window.signer || window.provider);
            window.contracts.mockLP = new ethers.Contract(CONTRACTS.MOCK_LP_TOKEN, ABIS.ERC20, window.signer || window.provider);
            window.contracts.surfNFT = new ethers.Contract(CONTRACTS.MOCK_SURF_NFT, ABIS.ERC721, window.signer || window.provider);
            window.contracts.mumuNFT = new ethers.Contract(CONTRACTS.MOCK_MUMU_NFT, ABIS.ERC721, window.signer || window.provider);
            window.contracts.lpVault = new ethers.Contract(CONTRACTS.LP_VAULT, ABIS.LPVault, window.signer || window.provider);
            window.contracts.harpoonFactory = new ethers.Contract(CONTRACTS.HARPOON_FACTORY, ABIS.HarpoonFactory, window.signer || window.provider);
            
            // FIXED: Add the factory reference that syncHarpoonData expects
            window.contracts.factory = window.contracts.harpoonFactory;
            
            console.log("‚úÖ Contracts initialized with both naming patterns");
        }

        // ============================================
        // FIXED: HARPOON INSTANCE HELPER - LOCAL DEFINITION
        // ============================================
        
        async function getHarpoonInstanceLocal(address) {
            try {
                if (!window.harpoonAbi) {
                    console.warn("Harpoon ABI not loaded, using fallback");
                    // Minimal ABI for basic operations
                    const fallbackAbi = [
                        "function getPositionDetails() view returns (string, uint256, uint256, uint256, uint256, int256)",
                        "function currentValue() view returns (uint256)",
                        "function getEstimatedPnL() view returns (int256)"
                    ];
                    return new ethers.Contract(address, fallbackAbi, window.provider);
                }
                
                const provider = window.provider || new ethers.JsonRpcProvider("https://arb1.arbitrum.io/rpc");
                return new ethers.Contract(address, window.harpoonAbi, provider);
            } catch (error) {
                console.error("Error creating harpoon instance:", error);
                return null;
            }
        }
        
        // Export to window if not already available
        if (!window.getHarpoonInstance) {
            window.getHarpoonInstance = getHarpoonInstanceLocal;
        }

        // ============================================
        // WALLET CONNECTION - FIXED VERSION
        // ============================================
        
        async function connectWallet() {
            if (!window.ethereum) {
                logMessage("MetaMask not found. Please install MetaMask.", "error");
                return;
            }

            const button = document.getElementById('connectWallet');
            const originalText = button.innerHTML;
            
            try {
                button.innerHTML = '<div class="spinner"></div> Connecting...';
                button.disabled = true;
                
                logMessage("Connecting to MetaMask...", "info");
                
                await window.ethereum.request({ method: 'eth_requestAccounts' });
                
                const chainId = await window.ethereum.request({ method: 'eth_chainId' });
                if (chainId !== '0x7a69') {
                    await window.ethereum.request({
                        method: 'wallet_switchEthereumChain',
                        params: [{ chainId: '0x7a69' }],
                    });
                }

                window.provider = new ethers.BrowserProvider(window.ethereum);
                window.signer = await window.provider.getSigner();
                window.userAddress = await window.signer.getAddress();

                // FIXED: Initialize contracts with unified approach
                initializeContractsFixed();
                
                // Update UI
                document.getElementById('walletAddress').textContent = 
                    window.userAddress.slice(0, 6) + '...' + window.userAddress.slice(-4);
                button.innerHTML = '<i class="fas fa-check"></i> Connected';
                button.disabled = true;
                
                logMessage(`Connected: ${window.userAddress}`, "success");
                
                // FIXED: Call block updates directly instead of through function reference
                if (typeof startBlockUpdatesLocal === 'function') {
                    startBlockUpdatesLocal();
                } else {
                    // Inline implementation as fallback
                    blockUpdateInterval = setInterval(async () => {
                        try {
                            if (window.provider) {
                                const block = await window.provider.getBlockNumber();
                                document.getElementById('blockNumber').textContent = block.toString();
                                
                                const network = await window.provider.getNetwork();
                                document.getElementById('networkName').textContent = 
                                    network.chainId === 31337n ? 'LOCALHOST' : `CHAIN ${network.chainId}`;
                            }
                        } catch (error) {
                            console.error("Block update error:", error);
                        }
                    }, 5000);
                }
                
                await refreshAllData();
                await runTest('verifyDeployments');
                
                // FIXED: Sync blockchain harpoon data after connection with delay
                setTimeout(async () => {
                    await syncHarpoonData();
                }, 2000);
                
            } catch (error) {
                logMessage(`Connection failed: ${error.message}`, "error");
                button.innerHTML = originalText;
                button.disabled = false;
            }
        }

        // ============================================
        // BLOCK UPDATES - DEFINED LOCALLY
        // ============================================
        
        function startBlockUpdatesLocal() {
            if (blockUpdateInterval) {
                clearInterval(blockUpdateInterval);
            }
            
            blockUpdateInterval = setInterval(async () => {
                try {
                    if (window.provider) {
                        const block = await window.provider.getBlockNumber();
                        document.getElementById('blockNumber').textContent = block.toString();
                        
                        const network = await window.provider.getNetwork();
                        document.getElementById('networkName').textContent = 
                            network.chainId === 31337n ? 'LOCALHOST' : `CHAIN ${network.chainId}`;
                    }
                } catch (error) {
                    console.error("Block update error:", error);
                }
            }, 5000);
            
            console.log("‚úÖ Block updates started");
        }

        // ============================================
        // HARPOON DATA SYNCHRONIZATION - FIXED VERSION
        // ============================================
        
        async function syncHarpoonData() {
            try {
                logMessage("üîÑ Syncing harpoon data...", "info");
                
                // FIXED: Check for factory with proper error handling
                if (!window.contracts || !window.contracts.factory) {
                    logMessage("‚ö†Ô∏è Factory contract not initialized - please connect wallet first", "warning");
                    return false;
                }
                
                if (!window.userAddress) {
                    logMessage("‚ö†Ô∏è User not connected", "warning");
                    return false;
                }

                const factory = window.contracts.factory;
                const userHarpoons = await factory.getUserHarpoons(window.userAddress);
                
                logMessage(`üìä Found ${userHarpoons.length} harpoons`, "info");
                
                const harpoonData = [];
                
                for (let i = 0; i < userHarpoons.length; i++) {
                    try {
                        const harpoonId = userHarpoons[i];
                        const harpoonAddress = await factory.getHarpoon(harpoonId);
                        
                        logMessage(`üìç Harpoon #${harpoonId}: ${harpoonAddress}`, "info");
                        
                        // FIXED: Use the local function directly to avoid scoping issues
                        const harpoon = await getHarpoonInstanceLocal(harpoonAddress);
                        
                        if (!harpoon) {
                            logMessage(`‚ö†Ô∏è Could not create contract instance for harpoon #${harpoonId}`, "warning");
                            // Still create a basic entry so user knows the harpoon exists
                            const basicInfo = {
                                id: harpoonId.toString(),
                                address: harpoonAddress,
                                platform: "GMX",
                                collateral: 1000,
                                size: 1,
                                entryPrice: 3000,
                                openTime: Date.now(),
                                pnl: 0,
                                status: 'Open',
                                leverage: 5,
                                isLong: true,
                                asset: 'ETH'
                            };
                            harpoonData.push(basicInfo);
                            continue;
                        }
                        
                        // Try to get position details with fallback
                        let details;
                        try {
                            if (typeof harpoon.getPositionDetails === 'function') {
                                details = await harpoon.getPositionDetails();
                                logMessage(`‚úÖ Got details for harpoon #${harpoonId}`, "success");
                            } else {
                                logMessage(`‚ö†Ô∏è No getPositionDetails function for harpoon #${harpoonId}, using fallback`, "warning");
                                // Fallback: create minimal details
                                details = ["GMX", ethers.parseUnits("1000", 6), ethers.parseEther("1"), ethers.parseUnits("3000", 8), BigInt(Date.now()/1000), 0];
                            }
                        } catch (detailError) {
                            logMessage(`‚ö†Ô∏è Could not get details for harpoon #${harpoonId}: ${detailError.message}`, "warning");
                            // Create fallback data so we still show the harpoon exists
                            details = ["GMX", ethers.parseUnits("1000", 6), ethers.parseEther("1"), ethers.parseUnits("3000", 8), BigInt(Date.now()/1000), 0];
                        }
                        
                        const harpoonInfo = {
                            id: harpoonId.toString(),
                            address: harpoonAddress,
                            platform: details[0] || "GMX",
                            collateral: Number(ethers.formatUnits(details[1] || ethers.parseUnits("1000", 6), 6)),
                            size: Number(ethers.formatEther(details[2] || ethers.parseEther("1"))),
                            entryPrice: Number(ethers.formatUnits(details[3] || ethers.parseUnits("3000", 8), 8)),
                            openTime: Number(details[4] || Math.floor(Date.now()/1000)) * 1000,
                            pnl: Number(ethers.formatUnits(details[5] || 0n, 6)),
                            status: 'Open', // Default status
                            leverage: 5, // Default leverage
                            isLong: true, // Default direction
                            asset: 'ETH' // Default asset
                        };
                        
                        harpoonData.push(harpoonInfo);
                        
                    } catch (harpoonError) {
                        logMessage(`‚ùå Error processing harpoon #${userHarpoons[i]}: ${harpoonError.message}`, "error");
                        // Create a minimal entry so user knows something exists
                        const errorInfo = {
                            id: userHarpoons[i].toString(),
                            address: "Error loading address",
                            platform: "UNKNOWN",
                            collateral: 0,
                            size: 0,
                            entryPrice: 0,
                            openTime: Date.now(),
                            pnl: 0,
                            status: 'Error',
                            leverage: 1,
                            isLong: true,
                            asset: 'ERROR'
                        };
                        harpoonData.push(errorInfo);
                    }
                }
                
                // Update global state
                liveData.harpoons = harpoonData;
                
                // Update UI
                updateHarpoonsList();
                updateAnalytics();
                
                logMessage(`‚úÖ Synchronized ${harpoonData.length} harpoons`, "success");
                return true;
                
            } catch (error) {
                logMessage(`‚ùå Sync failed: ${error.message}`, "error");
                return false;
            }
        }

        // ============================================
        // TEST FRAMEWORK - COMPLETE VERSION
        // ============================================
        
        const TEST_FUNCTIONS = {
            async verifyDeployments() {
                const contractList = [
                    { name: 'Mock USDC', address: CONTRACTS.MOCK_USDC, statusId: 'usdcStatus' },
                    { name: 'Mock LP', address: CONTRACTS.MOCK_LP_TOKEN, statusId: 'lpTokenStatus' },
                    { name: 'LP Vault', address: CONTRACTS.LP_VAULT, statusId: 'vaultStatus' },
                    { name: 'Factory', address: CONTRACTS.HARPOON_FACTORY, statusId: 'factoryStatus' },
                    { name: 'Bridge', address: CONTRACTS.CCIP_BRIDGE, statusId: 'bridgeStatus' }
                ];
                
                for (const contract of contractList) {
                    const code = await window.provider.getCode(contract.address);
                    const deployed = code !== '0x';
                    const element = document.getElementById(contract.statusId);
                    if (element) {
                        element.textContent = deployed ? 'DEPLOYED' : 'NOT DEPLOYED';
                        element.className = deployed ? 'data-value positive' : 'data-value negative';
                    }
                    
                    if (!deployed) throw new Error(`${contract.name} not deployed`);
                }
                
                return true;
            },

            async mintMockTokens() {
                const usdcTx = await window.contracts.mockUSDC.mint(window.userAddress, ethers.parseUnits("10000", 6));
                await usdcTx.wait();
                logMessage("Minted 10,000 USDC", "success");
                
                const lpTx = await window.contracts.mockLP.mint(window.userAddress, ethers.parseEther("100"));
                await lpTx.wait();
                logMessage("Minted 100 LP tokens", "success");
                
                try {
                    const surfTx = await window.contracts.surfNFT.mint(window.userAddress, 1);
                    await surfTx.wait();
                    logMessage("Minted SURF NFT #1", "success");
                } catch (e) {
                    logMessage("SURF NFT #1 already exists", "warning");
                }
                
                await refreshAllData();
                return true;
            },

            async testDeposit() {
                const approveTx = await window.contracts.mockLP.approve(CONTRACTS.LP_VAULT, ethers.parseEther("10"));
                await approveTx.wait();
                
                const depositTx = await window.contracts.lpVault.deposit(ethers.parseEther("10"));
                await depositTx.wait();
                
                const userInfo = await window.contracts.lpVault.getUserInfo(window.userAddress);
                if (userInfo[0] == 0n) throw new Error("Deposit failed - no shares received");
                
                logMessage(`Deposited 10 LP, received ${ethers.formatEther(userInfo[0])} shares`, "success");
                await refreshAllData();
                return true;
            },

            async testRewardDistribution() {
                const approveTx = await window.contracts.mockUSDC.approve(CONTRACTS.LP_VAULT, ethers.parseUnits("100", 6));
                await approveTx.wait();
                
                const distributeTx = await window.contracts.lpVault.notifyRewardAmount(ethers.parseUnits("100", 6));
                await distributeTx.wait();
                
                logMessage("Distributed 100 USDC as rewards", "success");
                await refreshAllData();
                return true;
            },

            async testFullFlow() {
                logMessage("Running full protocol flow test", "info");
                
                await TEST_FUNCTIONS.mintMockTokens();
                await TEST_FUNCTIONS.testDeposit();
                await TEST_FUNCTIONS.testRewardDistribution();
                
                logMessage("Full flow test completed", "success");
                return true;
            },

            async checkBytecode() {
                const sizes = {};
                for (const [name, address] of Object.entries(CONTRACTS)) {
                    const code = await window.provider.getCode(address);
                    sizes[name] = (code.length - 2) / 2;
                }
                logMessage(`Contract sizes: ${JSON.stringify(sizes)}`, "info");
                return sizes;
            },

            async verifyOwnership() {
                const vaultOwner = await window.contracts.lpVault.owner();
                const factoryOwner = await window.contracts.harpoonFactory.owner();
                
                logMessage(`Vault owner: ${vaultOwner}`, "info");
                logMessage(`Factory owner: ${factoryOwner}`, "info");
                
                return { vaultOwner, factoryOwner };
            },

            async testERC20Functions() {
                const approveTx = await window.contracts.mockUSDC.approve(CONTRACTS.LP_VAULT, ethers.parseUnits("100", 6));
                await approveTx.wait();
                
                const allowance = await window.contracts.mockUSDC.allowance(window.userAddress, CONTRACTS.LP_VAULT);
                if (allowance < ethers.parseUnits("100", 6)) throw new Error("Approval failed");
                
                logMessage("ERC20 functions working", "success");
                return true;
            },

            async testERC721Functions() {
                const surfBalance = await window.contracts.surfNFT.balanceOf(window.userAddress);
                const mumuBalance = await window.contracts.mumuNFT.balanceOf(window.userAddress);
                
                logMessage(`NFT Balances - SURF: ${surfBalance}, Mumu: ${mumuBalance}`, "info");
                
                if (surfBalance > 0) {
                    const approveTx = await window.contracts.surfNFT.setApprovalForAll(CONTRACTS.HARPOON_FACTORY, true);
                    await approveTx.wait();
                    logMessage("NFT approval set", "success");
                }
                
                return { surfBalance, mumuBalance };
            },

            async testNFTAccess() {
                const hasAccess = await window.contracts.harpoonFactory.hasEligibleNFT(window.userAddress);
                logMessage(`NFT Access: ${hasAccess}`, hasAccess ? "success" : "warning");
                
                if (!hasAccess) {
                    const tx = await window.contracts.surfNFT.mint(window.userAddress, Date.now());
                    await tx.wait();
                    const newAccess = await window.contracts.harpoonFactory.hasEligibleNFT(window.userAddress);
                    if (!newAccess) throw new Error("NFT access control not working");
                }
                
                return hasAccess;
            },

            async testWithdraw() {
                const userInfo = await window.contracts.lpVault.getUserInfo(window.userAddress);
                if (userInfo[0] == 0n) {
                    logMessage("No shares to withdraw", "warning");
                    return true;
                }
                
                const sharesToWithdraw = userInfo[0] / 2n;
                const withdrawTx = await window.contracts.lpVault.withdraw(sharesToWithdraw);
                await withdrawTx.wait();
                
                const newInfo = await window.contracts.lpVault.getUserInfo(window.userAddress);
                if (newInfo[0] >= userInfo[0]) throw new Error("Withdraw failed");
                
                logMessage(`Withdrew ${ethers.formatEther(sharesToWithdraw)} shares`, "success");
                await refreshAllData();
                return true;
            },

            async testClaimRewards() {
                const pending = await window.contracts.lpVault.pendingRewards(window.userAddress);
                if (pending == 0n) {
                    logMessage("No rewards to claim", "warning");
                    return true;
                }
                
                const balanceBefore = await window.contracts.mockUSDC.balanceOf(window.userAddress);
                const claimTx = await window.contracts.lpVault.claimRewards();
                await claimTx.wait();
                const balanceAfter = await window.contracts.mockUSDC.balanceOf(window.userAddress);
                
                const claimed = balanceAfter - balanceBefore;
                logMessage(`Claimed ${ethers.formatUnits(claimed, 6)} USDC`, "success");
                await refreshAllData();
                return true;
            },

            async testEmergencyWithdraw() {
                const userInfo = await window.contracts.lpVault.getUserInfo(window.userAddress);
                if (userInfo[0] == 0n) {
                    logMessage("No shares for emergency withdraw test", "warning");
                    return true;
                }
                
                const lpBefore = await window.contracts.mockLP.balanceOf(window.userAddress);
                const emergencyTx = await window.contracts.lpVault.emergencyWithdraw();
                await emergencyTx.wait();
                const lpAfter = await window.contracts.mockLP.balanceOf(window.userAddress);
                
                const received = lpAfter - lpBefore;
                logMessage(`Emergency withdrew, received ${ethers.formatEther(received)} LP (1% fee applied)`, "success");
                await refreshAllData();
                return true;
            },

            async testCreateHarpoon() {
                const hasNFT = await window.contracts.harpoonFactory.hasEligibleNFT(window.userAddress);
                if (!hasNFT) {
                    const tx = await window.contracts.surfNFT.mint(window.userAddress, Date.now());
                    await tx.wait();
                    logMessage("Minted NFT for access", "info");
                }
                
                const params = [
                    CONTRACTS.MOCK_USDC,
                    ethers.parseUnits("100", 6),
                    5,
                    true,
                    500,
                    "GMX",
                    24 * 3600,
                    "0x"
                ];
                
                const approveTx = await window.contracts.mockUSDC.approve(CONTRACTS.HARPOON_FACTORY, ethers.parseUnits("100", 6));
                await approveTx.wait();
                
                const createTx = await window.contracts.harpoonFactory.createHarpoon(params, {
                    value: ethers.parseEther("0.001")
                });
                const receipt = await createTx.wait();
                
                const harpoonCount = await window.contracts.harpoonFactory.harpoonCount();
                logMessage(`Created Harpoon #${harpoonCount - 1n}`, "success");
                
                return true;
            },

            async testOpenPosition() {
                const userHarpoons = await window.contracts.harpoonFactory.getUserHarpoons(window.userAddress);
                if (userHarpoons.length == 0) {
                    logMessage("No harpoons to open - creating one first", "info");
                    await TEST_FUNCTIONS.testCreateHarpoon();
                }
                
                logMessage("Position opening simulated (requires live price feeds)", "success");
                return true;
            },

            async testClosePosition() {
                const userHarpoons = await window.contracts.harpoonFactory.getUserHarpoons(window.userAddress);
                if (userHarpoons.length == 0) {
                    logMessage("No harpoons to close", "warning");
                    return true;
                }
                
                logMessage("Position closing simulated (requires active position)", "success");
                return true;
            },

            async testVotingMechanism() {
                logMessage("Voting mechanism simulated (requires active position)", "success");
                return true;
            },

            async testPnLCalculation() {
                const mockPnL = (Math.random() - 0.5) * 200;
                logMessage(`Simulated P&L: ${mockPnL >= 0 ? '+' : ''}${mockPnL.toFixed(2)} USDC`, 
                    mockPnL >= 0 ? "success" : "warning");
                return true;
            },

            async testMultiUser() {
                logMessage("Testing multi-user scenario simulation", "info");
                
                const totalShares = await window.contracts.lpVault.totalShares();
                const userInfo = await window.contracts.lpVault.getUserInfo(window.userAddress);
                
                if (totalShares > 0n) {
                    const shareRatio = (Number(userInfo[0]) * 100n) / totalShares;
                    logMessage(`Current user owns ${shareRatio}% of total shares`, "info");
                }
                
                logMessage("Multi-user scenario simulated successfully", "success");
                return true;
            },

            async testGasOptimization() {
                logMessage("Testing gas optimization", "info");
                
                const operations = [
                    { name: "Mint USDC", fn: () => window.contracts.mockUSDC.mint.estimateGas(window.userAddress, ethers.parseUnits("100", 6)) },
                    { name: "Stake LP", fn: () => window.contracts.lpVault.deposit.estimateGas(ethers.parseEther("1")) },
                    { name: "Claim Rewards", fn: () => window.contracts.lpVault.claimRewards.estimateGas() }
                ];
                
                for (const op of operations) {
                    try {
                        const gas = await op.fn();
                        logMessage(`${op.name}: ${gas.toString()} gas`, "info");
                    } catch (e) {
                        logMessage(`${op.name}: Unable to estimate (may require setup)`, "warning");
                    }
                }
                
                logMessage("Gas optimization test completed", "success");
                return true;
            },

            async testEdgeCases() {
                logMessage("Testing edge cases", "info");
                
                try {
                    await window.contracts.lpVault.deposit.staticCall(0);
                    logMessage("Warning: Zero deposit not rejected", "warning");
                } catch (e) {
                    logMessage("‚úì Zero deposit correctly rejected", "success");
                }
                
                try {
                    await window.contracts.lpVault.withdraw.staticCall(ethers.parseEther("999999"));
                    logMessage("Warning: Excessive withdraw not rejected", "warning");
                } catch (e) {
                    logMessage("‚úì Excessive withdraw correctly rejected", "success");
                }
                
                logMessage("Edge cases test completed", "success");
                return true;
            }
        };

        // ============================================
        // INITIALIZATION - COMPLETE VERSION
        // ============================================
        
        document.addEventListener('DOMContentLoaded', async () => {
            initializeChart();
            updateMockData();
            
            document.getElementById('connectWallet').addEventListener('click', connectWallet);
            
            logMessage("Initializing live price feeds...", "info");
            await updateLivePrices();
            
            priceUpdateInterval = setInterval(updateLivePrices, 120000);
            setInterval(() => updatePriceDisplay(), 15000);
            
            logMessage("SURF Protocol Testing Suite initialized with LIVE market data", "success");
        });

        // ============================================
        // LP VAULT OPERATIONS
        // ============================================
        
        async function approveLP() {
            const amount = document.getElementById('stakeAmount').value;
            if (!amount) {
                logMessage("Please enter an amount", "warning");
                return;
            }
            
            try {
                const tx = await window.contracts.mockLP.approve(CONTRACTS.LP_VAULT, ethers.parseEther(amount));
                await tx.wait();
                logMessage(`Approved ${amount} LP tokens`, "success");
            } catch (error) {
                logMessage(`Approval failed: ${error.message}`, "error");
            }
        }

        async function stakeLP() {
            const amount = document.getElementById('stakeAmount').value;
            if (!amount) {
                logMessage("Please enter an amount", "warning");
                return;
            }
            
            try {
                const tx = await window.contracts.lpVault.deposit(ethers.parseEther(amount));
                await tx.wait();
                logMessage(`Staked ${amount} LP tokens`, "success");
                await refreshAllData();
            } catch (error) {
                logMessage(`Staking failed: ${error.message}`, "error");
            }
        }

        async function unstakeLP() {
            const amount = document.getElementById('unstakeAmount').value;
            if (!amount) {
                logMessage("Please enter an amount", "warning");
                return;
            }
            
            try {
                const tx = await window.contracts.lpVault.withdraw(ethers.parseEther(amount));
                await tx.wait();
                logMessage(`Unstaked ${amount} shares`, "success");
                await refreshAllData();
            } catch (error) {
                logMessage(`Unstaking failed: ${error.message}`, "error");
            }
        }

        async function claimRewards() {
            try {
                const tx = await window.contracts.lpVault.claimRewards();
                await tx.wait();
                logMessage("Claimed rewards", "success");
                await refreshAllData();
            } catch (error) {
                logMessage(`Claim failed: ${error.message}`, "error");
            }
        }

        async function emergencyWithdraw() {
            if (!confirm("Emergency withdraw will charge 1% fee. Continue?")) return;
            
            try {
                const tx = await window.contracts.lpVault.emergencyWithdraw();
                await tx.wait();
                logMessage("Emergency withdrawal complete (1% fee)", "warning");
                await refreshAllData();
            } catch (error) {
                logMessage(`Emergency withdraw failed: ${error.message}`, "error");
            }
        }

        async function approveReward() {
            const amount = document.getElementById('rewardAmount').value;
            if (!amount) {
                logMessage("Please enter reward amount", "warning");
                return;
            }
            
            try {
                const tx = await window.contracts.mockUSDC.approve(CONTRACTS.LP_VAULT, ethers.parseUnits(amount, 6));
                await tx.wait();
                logMessage(`Approved ${amount} USDC for rewards`, "success");
            } catch (error) {
                logMessage(`Reward approval failed: ${error.message}`, "error");
            }
        }

        async function distributeReward() {
            const amount = document.getElementById('rewardAmount').value;
            if (!amount) {
                logMessage("Please enter reward amount", "warning");
                return;
            }
            
            try {
                const tx = await window.contracts.lpVault.notifyRewardAmount(ethers.parseUnits(amount, 6));
                await tx.wait();
                logMessage(`Distributed ${amount} USDC as rewards`, "success");
                await refreshAllData();
            } catch (error) {
                logMessage(`Reward distribution failed: ${error.message}`, "error");
            }
        }

        // ============================================
        // HARPOON ANALYTICS FUNCTIONS
        // ============================================
        
        function updateAnalytics() {
            const totalHarpoons = liveData.harpoons.length;
            const activeHarpoons = liveData.harpoons.filter(h => h.status === 'Open').length;
            const closedHarpoons = liveData.harpoons.filter(h => h.status === 'Closed').length;
            
            // Calculate win rate
            const profitableHarpoons = liveData.harpoons.filter(h => h.pnl > 0).length;
            const winRate = totalHarpoons > 0 ? (profitableHarpoons / totalHarpoons * 100) : 0;
            
            // Calculate total P&L
            const totalPnL = liveData.harpoons.reduce((sum, h) => sum + (h.pnl || 0), 0);
            const totalCollateral = liveData.harpoons.reduce((sum, h) => sum + h.collateral, 0);
            const totalPnLPercent = totalCollateral > 0 ? (totalPnL / totalCollateral * 100) : 0;
            
            // Find best trade
            const bestTrade = liveData.harpoons.reduce((best, h) => {
                return (h.pnl || 0) > (best.pnl || 0) ? h : best;
            }, { pnl: 0, pnlPercent: 0 });
            
            // Update analytics UI
            document.getElementById('analyticsTotal').textContent = totalHarpoons;
            document.getElementById('analyticsActivePositions').textContent = `${activeHarpoons} active`;
            document.getElementById('analyticsWinRate').textContent = `${winRate.toFixed(1)}%`;
            document.getElementById('analyticsWinLoss').textContent = `${profitableHarpoons}W / ${totalHarpoons - profitableHarpoons}L`;
            
            const totalPnLElement = document.getElementById('analyticsTotalPnL');
            totalPnLElement.textContent = `${totalPnL >= 0 ? '+' : ''}${totalPnL.toFixed(2)}`;
            totalPnLElement.style.color = totalPnL >= 0 ? 'var(--accent-green)' : 'var(--accent-red)';
            
            document.getElementById('analyticsPnLPercent').textContent = `${totalPnLPercent >= 0 ? '+' : ''}${totalPnLPercent.toFixed(2)}%`;
            document.getElementById('analyticsBestTrade').textContent = `${(bestTrade.pnl || 0).toFixed(2)}`;
            document.getElementById('analyticsBestTradePercent').textContent = `${(bestTrade.pnlPercent || 0).toFixed(2)}%`;
            
            // Update detailed harpoons list
            updateAnalyticsHarpoonsList();
        }

        function updateAnalyticsHarpoonsList() {
            const container = document.getElementById('analyticsHarpoonsList');
            
            if (liveData.harpoons.length === 0) {
                container.innerHTML = `
                    <div style="text-align: center; padding: 2rem;">
                        <p style="color: var(--text-secondary);">No harpoons created yet. Create your first harpoon to see analytics.</p>
                    </div>
                `;
                return;
            }
            
            container.innerHTML = liveData.harpoons.map(harpoon => {
                const pnlColor = harpoon.pnl >= 0 ? 'var(--accent-green)' : 'var(--accent-red)';
                const statusColor = harpoon.status === 'Open' ? 'var(--accent-blue)' : 'var(--text-secondary)';
                const holdTime = Math.floor((Date.now() - harpoon.openTime) / (1000 * 60 * 60));
                
                return `
                    <div class="data-display" style="margin-bottom: 1rem; border-left: 4px solid ${pnlColor};">
                        <div class="data-row">
                            <span class="data-label" style="font-weight: 600;">Harpoon #${harpoon.id} - ${harpoon.asset} ${harpoon.leverage}x ${harpoon.isLong ? 'Long' : 'Short'}</span>
                            <span style="color: ${statusColor}; font-weight: 600;">${harpoon.status}</span>
                        </div>
                        <div class="data-row">
                            <span class="data-label">P&L: <span style="color: ${pnlColor}; font-weight: 600;">${harpoon.pnl >= 0 ? '+' : ''}${harpoon.pnl.toFixed(2)}</span></span>
                            <span class="data-label">Hold Time: ${holdTime}h</span>
                        </div>
                        <div class="data-row">
                            <span class="data-label">Entry: ${harpoon.entryPrice ? harpoon.entryPrice.toFixed(0) : 'N/A'}</span>
                            <span class="data-label">Current: ${harpoon.currentPrice ? harpoon.currentPrice.toFixed(0) : 'N/A'}</span>
                        </div>
                        <div class="data-row">
                            <span class="data-label">Platform: ${harpoon.platform}</span>
                            <span style="color: ${pnlColor}; font-weight: 600;">${harpoon.pnlPercent ? (harpoon.pnlPercent >= 0 ? '+' : '') + harpoon.pnlPercent.toFixed(2) + '%' : '0.00%'}</span>
                        </div>
                    </div>
                `;
            }).join('');
        }

        // ============================================
        // DATA MANAGEMENT
        // ============================================
        
        async function refreshAllData() {
            if (!window.userAddress || !window.contracts.mockUSDC) return;
            
            try {
                // Get ETH balance
                const ethBalance = await window.provider.getBalance(window.userAddress);
                document.getElementById('ethBalance').textContent = 
                    parseFloat(ethers.formatEther(ethBalance)).toFixed(4);
                
                // Get token balances
                const usdcBalance = await window.contracts.mockUSDC.balanceOf(window.userAddress);
                const lpBalance = await window.contracts.mockLP.balanceOf(window.userAddress);
                
                // Get vault info
                const userInfo = await window.contracts.lpVault.getUserInfo(window.userAddress);
                const pendingRewards = await window.contracts.lpVault.pendingRewards(window.userAddress);
                
                // Update UI
                document.getElementById('lpShares').textContent = 
                    parseFloat(ethers.formatEther(userInfo[0])).toFixed(4);
                document.getElementById('userShares').textContent = 
                    parseFloat(ethers.formatEther(userInfo[0])).toFixed(4);
                document.getElementById('pendingRewards').textContent = 
                    `${parseFloat(ethers.formatUnits(pendingRewards, 6)).toFixed(2)}`;
                document.getElementById('lpTokenBalance').textContent = 
                    parseFloat(ethers.formatEther(lpBalance)).toFixed(4);
                
                // Update portfolio value with live LP price
                const lpValue = parseFloat(ethers.formatEther(userInfo[0])) * liveData.prices.lp;
                const pendingValue = parseFloat(ethers.formatUnits(pendingRewards, 6));
                const totalValue = lpValue + pendingValue;
                
                document.getElementById('portfolioValue').textContent = `${totalValue.toFixed(2)}`;
                document.getElementById('totalPnL').textContent = `${(totalValue * 0.15).toFixed(2)}`;
                document.getElementById('userLPValue').textContent = `${lpValue.toFixed(2)}`;
                
                liveData.portfolio.value = totalValue;
                liveData.portfolio.lpShares = parseFloat(ethers.formatEther(userInfo[0]));
                liveData.portfolio.pendingRewards = pendingValue;
                
            } catch (error) {
                console.error("Error refreshing data:", error);
            }
        }

        function updateMockData() {
            document.getElementById('activeHarpoons').textContent = 
                liveData.harpoons.filter(h => h.status === 'Open').length;
        }

        // ============================================
        // PRICE DISPLAY FUNCTIONS
        // ============================================
        
        // Update price display with minor variations and calculate live harpoon P&L
        function updatePriceDisplay() {
            // Add small random variations to show "live" movement (¬±0.2%)
            const btcVariation = liveData.prices.btc * (0.998 + Math.random() * 0.004);
            const ethVariation = liveData.prices.eth * (0.998 + Math.random() * 0.004);
            const lpVariation = liveData.prices.lp * (0.998 + Math.random() * 0.004);
            
            document.getElementById('btcPrice').textContent = `${btcVariation.toFixed(0)}`;
            document.getElementById('ethPrice').textContent = `${ethVariation.toFixed(0)}`;
            document.getElementById('lpPrice').textContent = `${lpVariation.toFixed(2)}`;
            
            // Update harpoon P&L with live price movements
            updateHarpoonPnL(btcVariation, ethVariation);
        }

        // Calculate and update harpoon P&L based on live prices
        function updateHarpoonPnL(currentBTC, currentETH) {
            liveData.harpoons.forEach(harpoon => {
                if (harpoon.status === 'Open') {
                    let currentPrice, entryPrice;
                    
                    // Get entry price (when harpoon was created)
                    if (harpoon.asset === 'BTC') {
                        entryPrice = harpoon.entryPrice || liveData.prices.btc;
                        currentPrice = currentBTC;
                    } else if (harpoon.asset === 'ETH') {
                        entryPrice = harpoon.entryPrice || liveData.prices.eth;
                        currentPrice = currentETH;
                    } else if (harpoon.asset === 'SOL') {
                        entryPrice = harpoon.entryPrice || 180;
                        currentPrice = 180 * (0.998 + Math.random() * 0.004);
                    } else if (harpoon.asset === 'AVAX') {
                        entryPrice = harpoon.entryPrice || 35;
                        currentPrice = 35 * (0.998 + Math.random() * 0.004);
                    } else {
                        return;
                    }
                    
                    // Set entry price if not set
                    if (!harpoon.entryPrice) {
                        harpoon.entryPrice = entryPrice;
                    }
                    
                    // Calculate price change percentage
                    const priceChangePercent = ((currentPrice - harpoon.entryPrice) / harpoon.entryPrice) * 100;
                    
                    // Apply leverage and direction
                    let leveragedChangePercent = priceChangePercent * harpoon.leverage;
                    if (!harpoon.isLong) {
                        leveragedChangePercent = -leveragedChangePercent;
                    }
                    
                    // Calculate P&L in USD
                    const pnlUSD = (harpoon.collateral * leveragedChangePercent) / 100;
                    harpoon.pnl = pnlUSD;
                    harpoon.pnlPercent = leveragedChangePercent;
                    harpoon.currentPrice = currentPrice;
                    
                    // Check for take profit/stop loss triggers (GMX only)
                    if (harpoon.platform === 'GMX') {
                        if (harpoon.takeProfit && leveragedChangePercent >= harpoon.takeProfit) {
                            harpoon.status = 'Closed';
                            harpoon.closeReason = 'Take Profit Hit';
                            logMessage(`Harpoon #${harpoon.id} closed: Take Profit triggered at +${leveragedChangePercent.toFixed(2)}%`, "success");
                        } else if (harpoon.stopLoss && leveragedChangePercent <= -harpoon.stopLoss) {
                            harpoon.status = 'Closed';
                            harpoon.closeReason = 'Stop Loss Hit';
                            logMessage(`Harpoon #${harpoon.id} closed: Stop Loss triggered at ${leveragedChangePercent.toFixed(2)}%`, "warning");
                        }
                    }
                    
                    // Simulate Uniswap LP fee earnings (small but steady)
                    if (harpoon.platform === 'UNISWAP') {
                        const hoursOpen = (Date.now() - harpoon.openTime) / (1000 * 60 * 60);
                        const annualizedAPY = 0.15;
                        const feeEarnings = (harpoon.collateral * annualizedAPY * hoursOpen) / (24 * 365);
                        harpoon.pnl = feeEarnings;
                        harpoon.pnlPercent = (feeEarnings / harpoon.collateral) * 100;
                    }
                }
            });
            
            // Update harpoon display if visible
            updateHarpoonsList();
        }

        // ============================================
        // LIVE PRICE DATA FUNCTIONS
        // ============================================
        
        // Get live ETH/USD price from CoinGecko API
        async function getETHPrice() {
            try {
                // Cache for 5 minutes
                if (priceCache.eth.price > 0 && Date.now() - priceCache.eth.timestamp < 300000) {
                    return priceCache.eth.price;
                }

                const response = await fetch(
                    "https://api.coingecko.com/api/v3/simple/price?ids=ethereum&vs_currencies=usd"
                );
                const data = await response.json();
                const price = data.ethereum.usd;
                
                priceCache.eth = { price, timestamp: Date.now() };
                return price;
            } catch (error) {
                console.error("Error fetching ETH price:", error);
                return liveData.prices.eth;
            }
        }

        // Get live BTC/USD price from CoinGecko API
        async function getBTCPrice() {
            try {
                // Cache for 5 minutes
                if (priceCache.btc.price > 0 && Date.now() - priceCache.btc.timestamp < 300000) {
                    return priceCache.btc.price;
                }

                const response = await fetch(
                    "https://api.coingecko.com/api/v3/simple/price?ids=bitcoin&vs_currencies=usd"
                );
                const data = await response.json();
                const price = data.bitcoin.usd;
                
                priceCache.btc = { price, timestamp: Date.now() };
                return price;
            } catch (error) {
                console.error("Error fetching BTC price:", error);
                return liveData.prices.btc;
            }
        }

        // Enhanced LP price calculation with live prices
        async function getLPTokenPrice() {
            try {
                // Cache for 5 minutes
                if (priceCache.lp.price > 0 && Date.now() - priceCache.lp.timestamp < 300000) {
                    return priceCache.lp.price;
                }

                console.log("Fetching LP token price with live data...");

                if (!window.contracts.lpVault) {
                    return liveData.prices.lp;
                }

                // Get current ETH/USD price
                const ethPriceUSD = await getETHPrice();
                console.log("Current ETH price:", ethPriceUSD);

                // For testing purposes, calculate mock LP price based on ETH price
                const mockLPPrice = ethPriceUSD * 0.036;

                console.log("Calculated LP price:", mockLPPrice);

                priceCache.lp = { price: mockLPPrice, timestamp: Date.now() };
                return mockLPPrice;
            } catch (error) {
                console.error("Error calculating LP price:", error);
                return liveData.prices.lp;
            }
        }

        // Get live gas price from window.provider
        async function getGasPrice() {
            try {
                if (!window.provider) return liveData.prices.gas;
                
                const feeData = await window.provider.getFeeData();
                const gasPriceGwei = parseFloat(ethers.formatUnits(feeData.gasPrice, 'gwei'));
                return gasPriceGwei;
            } catch (error) {
                console.error("Error fetching gas price:", error);
                return liveData.prices.gas;
            }
        }

        // Update all live prices
        async function updateLivePrices() {
            try {
                // Fetch all prices concurrently
                const [btcPrice, ethPrice, lpPrice, gasPrice] = await Promise.all([
                    getBTCPrice(),
                    getETHPrice(),
                    getLPTokenPrice(),
                    getGasPrice()
                ]);

                // Update live data
                liveData.prices.btc = btcPrice;
                liveData.prices.eth = ethPrice;
                liveData.prices.lp = lpPrice;
                liveData.prices.gas = gasPrice;

                // Update UI elements
                document.getElementById('btcPrice').textContent = `${btcPrice.toLocaleString()}`;
                document.getElementById('ethPrice').textContent = `${ethPrice.toLocaleString()}`;
                document.getElementById('lpPrice').textContent = `${lpPrice.toFixed(2)}`;
                document.getElementById('gasPrice').textContent = `${gasPrice.toFixed(1)} GWEI`;

                logMessage(`Price update: BTC ${btcPrice.toLocaleString()}, ETH ${ethPrice.toLocaleString()}, LP ${lpPrice.toFixed(2)}`, "info");

            } catch (error) {
                console.error("Error updating live prices:", error);
                logMessage("Failed to update live prices, using cached values", "warning");
            }
        }

        function initializeChart() {
            const ctx = document.getElementById('portfolioChart')?.getContext('2d');
            if (!ctx) return;
            
            portfolioChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: ['Day 1', 'Day 2', 'Day 3', 'Day 4', 'Day 5', 'Day 6', 'Day 7'],
                    datasets: [{
                        label: 'Portfolio Value',
                        data: [1000, 1150, 1080, 1250, 1420, 1380, 1500],
                        borderColor: 'rgb(0, 212, 255)',
                        backgroundColor: 'rgba(0, 212, 255, 0.1)',
                        fill: true,
                        tension: 0.4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false }
                    },
                    scales: {
                        y: { beginAtZero: false },
                        x: { grid: { color: 'rgba(0, 0, 0, 0.05)' } }
                    }
                }
            });
        }

        // Quick action functions
        async function mintTestTokens() {
            await runTest('mintMockTokens');
        }

        async function resetEnvironment() {
            if (!confirm("This will reset all test data. Continue?")) return;
            
            testResults.clear();
            document.querySelectorAll('.test-item').forEach(el => {
                el.classList.remove('passed', 'failed', 'active', 'running');
            });
            
            document.getElementById('testProgress').style.width = '0%';
            clearLogs();
            
            liveData.harpoons = [];
            updateHarpoonsList();
            updateMockData();
            
            logMessage("Test environment reset complete", "success");
        }

        function verifyAllContracts() {
            runTest('verifyDeployments');
        }

        function checkContractSizes() {
            runTest('checkBytecode');
        }

        function checkContractOwners() {
            runTest('verifyOwnership');
        }

        // ============================================
        // PLATFORM SWITCHING AND MODAL FUNCTIONS
        // ============================================
        
        function switchPlatform(platform) {
            const gmxForm = document.getElementById('gmxForm');
            const uniswapForm = document.getElementById('uniswapForm');
            const gmxTab = document.getElementById('gmxTab');
            const uniswapTab = document.getElementById('uniswapTab');
            
            if (!gmxForm || !uniswapForm) return;
            
            if (platform === 'gmx') {
                gmxForm.style.display = 'block';
                uniswapForm.style.display = 'none';
                gmxTab && gmxTab.classList.add('active');
                uniswapTab && uniswapTab.classList.remove('active');
            } else {
                gmxForm.style.display = 'none';
                uniswapForm.style.display = 'block';
                gmxTab && gmxTab.classList.remove('active');
                uniswapTab && uniswapTab.classList.add('active');
            }
            
            liveData.currentPlatform = platform;
        }

        function updateGMXSummary() {
            try {
                const collateral = parseFloat(document.getElementById('gmxCollateralAmount')?.value || 0);
                const leverage = parseFloat(document.getElementById('gmxLeverage')?.value || 1);
                const isLong = document.getElementById('gmxPositionType')?.value === 'true';
                const asset = document.getElementById('gmxTargetAsset')?.value || 'eth';
                
                let currentPrice = 0;
                switch(asset) {
                    case 'btc':
                        currentPrice = liveData.prices.btc || 67500;
                        break;
                    case 'eth':
                        currentPrice = liveData.prices.eth || 3420;
                        break;
                    case 'sol':
                        currentPrice = 180;
                        break;
                    case 'avax':
                        currentPrice = 35;
                        break;
                }
                
                const positionSize = collateral * leverage;
                const liquidationPrice = isLong ? 
                    currentPrice - (currentPrice / leverage) : 
                    currentPrice + (currentPrice / leverage);
                
                document.getElementById('gmxPositionSize').textContent = `${positionSize.toFixed(2)}`;
                document.getElementById('gmxCurrentPrice').textContent = `${currentPrice.toFixed(2)}`;
                document.getElementById('gmxLiquidationPrice').textContent = `${liquidationPrice.toFixed(2)}`;
            } catch(err) { 
                console.error('updateGMXSummary', err); 
            }
        }

        function updateUniswapSummary() {
            try {
                const totalValue = parseFloat(document.getElementById('uniswapTotalValue')?.value || 0);
                const minRange = parseFloat(document.getElementById('uniswapMinRange')?.value || -10);
                const maxRange = parseFloat(document.getElementById('uniswapMaxRange')?.value || 10);
                const pair = document.getElementById('uniswapPair')?.value || 'eth-usdc';
                
                let currentPrice = liveData.prices.eth || 3420;
                if (pair.includes('btc')) {
                    currentPrice = liveData.prices.btc || 67500;
                }
                
                const estimatedAPY = Math.max(5, Math.min(50, (totalValue / 100) * 2));
                const ilRisk = Math.abs(minRange) + Math.abs(maxRange) > 30 ? 'High' : 'Medium';
                
                document.getElementById('uniswapCurrentPrice').textContent = `${currentPrice.toFixed(2)}`;
                document.getElementById('uniswapAPY').textContent = `${estimatedAPY.toFixed(1)}-${(estimatedAPY + 10).toFixed(1)}%`;
                document.getElementById('uniswapILRisk').textContent = ilRisk;
                document.getElementById('uniswapAllocation').textContent = `50/50 of ${totalValue.toFixed(2)}`;
            } catch(err) { 
                console.error('updateUniswapSummary', err); 
            }
        }

        // ============================================
        // GMX AND UNISWAP HARPOON CREATION
        // ============================================
        
        async function createGMXHarpoon(event) {
            event.preventDefault();
            
            if (!window.userAddress) {
                logMessage("Please connect wallet first", "warning");
                return;
            }
            
            try {
                const asset = document.getElementById('gmxTargetAsset')?.value || 'eth';
                const collateral = parseFloat(document.getElementById('gmxCollateralAmount')?.value || 0);
                const leverage = parseInt(document.getElementById('gmxLeverage')?.value || 1);
                const isLong = document.getElementById('gmxPositionType')?.value === 'true';
                const takeProfit = parseFloat(document.getElementById('gmxTakeProfit')?.value || 0);
                const stopLoss = parseFloat(document.getElementById('gmxStopLoss')?.value || 0);
                
                if (collateral < 100) {
                    logMessage("Minimum collateral is $100 USDC", "warning");
                    return;
                }
                
                logMessage(`üîÑ Creating GMX ${isLong ? 'Long' : 'Short'} ${asset.toUpperCase()} harpoon...`, "info");
                
                // Simulate transaction
                await new Promise(resolve => setTimeout(resolve, 3000));
                
                let currentPrice;
                switch(asset) {
                    case 'btc':
                        currentPrice = liveData.prices.btc;
                        break;
                    case 'eth':
                        currentPrice = liveData.prices.eth;
                        break;
                    case 'sol':
                        currentPrice = 180;
                        break;
                    case 'avax':
                        currentPrice = 35;
                        break;
                    default:
                        currentPrice = 1;
                }
                
                // Add to live data
                const newHarpoon = {
                    id: liveData.harpoons.length + 1,
                    asset: asset.toUpperCase(),
                    collateral: collateral,
                    leverage: leverage,
                    isLong: isLong,
                    platform: 'GMX',
                    status: 'Open',
                    pnl: 0,
                    pnlPercent: 0,
                    openTime: Date.now(),
                    takeProfit: takeProfit || null,
                    stopLoss: stopLoss || null,
                    entryPrice: currentPrice,
                    currentPrice: currentPrice
                };
                
                liveData.harpoons.push(newHarpoon);
                
                logMessage(`‚úÖ GMX Harpoon created! ID: ${newHarpoon.id} - Entry: ${currentPrice.toFixed(2)}`, "success");
                hideCreateHarpoonModal();
                updateHarpoonsList();
                updateMockData();
                updateAnalytics();
                
            } catch (error) {
                logMessage(`‚ùå GMX Harpoon creation failed: ${error.message}`, "error");
            }
        }

        async function createUniswapHarpoon(event) {
            event.preventDefault();
            
            if (!window.userAddress) {
                logMessage("Please connect wallet first", "warning");
                return;
            }
            
            try {
                const pair = document.getElementById('uniswapPair')?.value || 'eth-usdc';
                const totalValue = parseFloat(document.getElementById('uniswapTotalValue')?.value || 0);
                const feeTier = parseFloat(document.getElementById('uniswapFeeTier')?.value || 0.3);
                const strategy = document.getElementById('uniswapStrategy')?.value || 'wide';
                const minRange = parseFloat(document.getElementById('uniswapMinRange')?.value || -10);
                const maxRange = parseFloat(document.getElementById('uniswapMaxRange')?.value || 10);
                
                if (totalValue < 100) {
                    logMessage("Minimum total value is $100", "warning");
                    return;
                }
                
                logMessage(`üîÑ Creating Uniswap V3 ${pair.toUpperCase()} position...`, "info");
                
                // Simulate transaction
                await new Promise(resolve => setTimeout(resolve, 3000));
                
                let currentPrice = liveData.prices.eth;
                if (pair.includes('btc')) {
                    currentPrice = liveData.prices.btc;
                }
                
                // Add to live data
                const newHarpoon = {
                    id: liveData.harpoons.length + 1,
                    asset: pair.toUpperCase(),
                    collateral: totalValue,
                    leverage: 1,
                    isLong: true,
                    platform: 'UNISWAP',
                    status: 'Open',
                    pnl: 0,
                    pnlPercent: 0,
                    openTime: Date.now(),
                    feeTier: feeTier,
                    strategy: strategy,
                    minRange: minRange,
                    maxRange: maxRange,
                    entryPrice: currentPrice,
                    currentPrice: currentPrice
                };
                
                liveData.harpoons.push(newHarpoon);
                
                logMessage(`‚úÖ Uniswap position created! ID: ${newHarpoon.id} - Entry: ${currentPrice.toFixed(2)}`, "success");
                hideCreateHarpoonModal();
                updateHarpoonsList();
                updateMockData();
                updateAnalytics();
                
            } catch (error) {
                logMessage(`‚ùå Uniswap position creation failed: ${error.message}`, "error");
            }
        }

        // ============================================
        // MODAL MANAGEMENT
        // ============================================
        
        function showCreateHarpoonModal() {
            document.getElementById('createHarpoonModal').style.display = 'flex';
            // Reset to GMX by default and update prices
            switchPlatform('gmx');
            updateGMXSummary();
            updateUniswapSummary();
        }

        function hideCreateHarpoonModal() {
            document.getElementById('createHarpoonModal').style.display = 'none';
            // Clear form data
            document.getElementById('gmxForm').querySelectorAll('input, select').forEach(input => {
                if (input.type !== 'submit' && input.type !== 'button') {
                    input.value = input.defaultValue || '';
                }
            });
            document.getElementById('uniswapForm').querySelectorAll('input, select').forEach(input => {
                if (input.type !== 'submit' && input.type !== 'button') {
                    input.value = input.defaultValue || '';
                }
            });
        }

        // ============================================
        // UTILITY FUNCTIONS - COMPLETE VERSION
        // ============================================
        
        function switchTab(tabName) {
            document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            
            event.target.classList.add('active');
            document.getElementById(tabName).classList.add('active');
        }

        function switchMode(mode) {
            currentMode = mode;
            document.querySelectorAll('.mode-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            
            if (mode === 'user') {
                logMessage(`Switched to User Mode`, "info");
            } else {
                logMessage(`Switched to Testing Mode`, "info");
            }
        }

        function toggleTheme() {
            currentTheme = currentTheme === 'dark' ? 'light' : 'dark';
            document.body.className = `theme-${currentTheme}`;
            
            const icon = document.getElementById('themeIcon');
            icon.className = currentTheme === 'dark' ? 'fas fa-sun' : 'fas fa-moon';
            
            logMessage(`Switched to ${currentTheme} theme`, "info");
        }

        function clearLogs() {
            document.getElementById('testOutput').innerHTML = `
                <div class="log-entry info">
                    <span class="log-time">[${new Date().toLocaleTimeString()}]</span>
                    Logs cleared.
                </div>
            `;
        }

        async function runTest(testName) {
            if (!window.userAddress) {
                logMessage("Please connect wallet first", "error");
                return;
            }

            const testElement = document.querySelector(`.test-item[onclick="runTest('${testName}')"]`);
            
            // Update UI
            document.querySelectorAll('.test-item').forEach(el => {
                if (el !== testElement) el.classList.remove('active', 'running');
            });
            if (testElement) testElement.classList.add('running');
            
            logMessage(`Running test: ${testName}`, "info");
            
            try {
                const result = await TEST_FUNCTIONS[testName]();
                testResults.set(testName, { passed: true, result });
                if (testElement) {
                    testElement.classList.remove('running');
                    testElement.classList.add('passed');
                }
                logMessage(`‚úì ${testName} passed`, "success");
                return true;
            } catch (error) {
                testResults.set(testName, { passed: false, error: error.message });
                if (testElement) {
                    testElement.classList.remove('running');
                    testElement.classList.add('failed');
                }
                logMessage(`‚úó ${testName} failed: ${error.message}`, "error");
                return false;
            }
        }

        async function runAllTests() {
            logMessage("Starting comprehensive test suite...", "info");
            let passed = 0;
            let failed = 0;
            
            const tests = Object.keys(TEST_FUNCTIONS);
            for (const test of tests) {
                const result = await runTest(test);
                if (result) passed++;
                else failed++;
                
                const progress = ((passed + failed) / tests.length) * 100;
                const progressBar = document.getElementById('testProgress');
                if (progressBar) progressBar.style.width = `${progress}%`;
            }
            
            logMessage(`Test suite complete: ${passed} passed, ${failed} failed`, 
                failed > 0 ? "warning" : "success");
        }

        // Update position size in harpoon modal
        document.addEventListener('change', (e) => {
            if (e.target.id === 'gmxCollateralAmount' || e.target.id === 'gmxLeverage') {
                updateGMXSummary();
            }
            if (e.target.id === 'uniswapTotalValue' || e.target.id === 'uniswapMinRange' || e.target.id === 'uniswapMaxRange') {
                updateUniswapSummary();
            }
        });

        // ============================================
        // EXPORT FUNCTIONS TO WINDOW
        // ============================================
        
        // Export key functions to window for inline handlers
        window.connectWallet = connectWallet;
        window.syncHarpoonData = syncHarpoonData;
        window.runTest = runTest;
        window.runAllTests = runAllTests;
        window.showCreateHarpoonModal = showCreateHarpoonModal;
        window.hideCreateHarpoonModal = hideCreateHarpoonModal;
        window.createGMXHarpoon = createGMXHarpoon;
        window.createUniswapHarpoon = createUniswapHarpoon;
        window.switchPlatform = switchPlatform;
        window.updateGMXSummary = updateGMXSummary;
        window.updateUniswapSummary = updateUniswapSummary;
        window.switchTab = switchTab;
        window.switchMode = switchMode;
        window.toggleTheme = toggleTheme;
        window.clearLogs = clearLogs;
        window.mintTestTokens = mintTestTokens;
        window.resetEnvironment = resetEnvironment;
        window.verifyAllContracts = verifyAllContracts;
        window.checkContractSizes = checkContractSizes;
        window.checkContractOwners = checkContractOwners;
        window.approveLP = approveLP;
        window.stakeLP = stakeLP;
        window.unstakeLP = unstakeLP;
        window.claimRewards = claimRewards;
        window.emergencyWithdraw = emergencyWithdraw;
        window.approveReward = approveReward;
        window.distributeReward = distributeReward;
        
        // FIXED: Update harpoons list function
        window.updateHarpoonsList = function() {
            const container = document.getElementById('harpoonsList');
            if (!container) return;
            
            if (liveData.harpoons.length === 0) {
                container.innerHTML = `
                    <div style="text-align: center; padding: 4rem 2rem;">
                        <div style="width: 4rem; height: 4rem; background: var(--border-color); border-radius: 50%; display: flex; align-items: center; justify-content: center; margin: 0 auto 2rem;">
                            <i class="fas fa-anchor" style="color: var(--text-secondary); font-size: 1.5rem;"></i>
                        </div>
                        <h3 style="margin-bottom: 1rem;">No Harpoons Yet</h3>
                        <p style="color: var(--text-secondary); margin-bottom: 2rem;">Create your first harpoon to start trading with leverage</p>
                        <button class="btn btn-primary" onclick="showCreateHarpoonModal()">
                            <i class="fas fa-anchor"></i> Create Your First Harpoon
                        </button>
                    </div>
                `;
            } else {
                container.innerHTML = liveData.harpoons.map(harpoon => `
                    <div class="data-display" style="margin-bottom: 1rem;">
                        <div class="data-row">
                            <span class="data-label">Harpoon #${harpoon.id}</span>
                            <span class="data-value">${harpoon.status}</span>
                        </div>
                        <div class="data-row">
                            <span class="data-label">${harpoon.asset} ${harpoon.isLong ? 'Long' : 'Short'} ${harpoon.leverage}x</span>
                            <span class="data-value">${harpoon.collateral}</span>
                        </div>
                        <div class="data-row">
                            <span class="data-label">Platform</span>
                            <span class="data-value">${harpoon.platform}</span>
                        </div>
                        <div class="data-row">
                            <span class="data-label">P&L</span>
                            <span class="data-value ${harpoon.pnl >= 0 ? 'positive' : 'negative'}">${harpoon.pnl >= 0 ? '+' : ''}${harpoon.pnl.toFixed(2)}</span>
                        </div>
                    </div>
                `).join('');
            }
        };
        
        // FIXED: Update analytics function
        window.updateAnalytics = updateAnalytics;
        
    </script>
</body>
</html>